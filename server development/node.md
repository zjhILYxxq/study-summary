#### node 相关

1. `node` 为什么要选择 `javascript` 作为实现语言？

    `node` 的作者以前的工作都是围绕高性能 `Web` 服务器进行的。

    设计高性能 `Web` 服务器的要点: 事件驱动、非阻塞 `I/O`。

    `node` 的作者最开始的目标是想写一个基于事件驱动、非阻塞 `I/O` 的 `Web` 服务器，还要没有历史负担，综合考虑下 `javascript` 比较合适。

2. `node` 的特点

    异步 `I/O`: `node` 中，绝大多数的操作都是以异步的方式调用。

    事件与回调函数

    单线程: 好处是不需要像多线编程一样处处在意状态同步问题，缺点是无法利用多核 `CPU`、应用的健壮性差(错误会引起整个程序退出)、大量计算会占用 `CPU` 导致无法继续调用异步 `I/0`。 大计算量的问题，可以通过 `Web Worker` 和 `child_process` 来解决。

    跨平台: 通过 `libuv` 可以实现跨平台。

3. `node` 的应用场景

    I/O 密集型，主要归功于事件循环的处理能力。

    CPU 密集型也可以借助 child_process 及合理的调度实现。

    分布式应用 + 和遗留系统和平共处

4. `node` 的模块机制

    `javascript` 先天缺乏一项功能: 模块机制。

    `commonjs` 规范的提出，主要是为了弥补 `javascript` 的缺陷，以达到像 `Java`、`Ruby`、`Pyhon` 等一样具备开发大型应用的能力，而不仅仅停留在小脚本程序的阶段。其中涵盖了模块、二进制 `buffer`、字符集编码、`I/O` 流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

    在 `node` 中引入模块，需要经历以下 `3` 个步骤:
    - 路径分析
    - 文件定位
    - 编译执行

    在 `node` 中，模块分为两类:
    - `node` 提供的模块，称为核心模块。在 node 进程启动时，部分核心模块就已经加载进内存中了，所以这部分模块在引入时，文件定位和编译执行步骤可以省略掉，并且在路径分析中优先判断，加载速度最快。
    - 用户自己编写的模块，称为文件模块。这类型的模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行，速度要比核心模块慢。

    不管是核心模块还是文件模块，`require` 方法对相同模块的二次加载都一律采用缓存优先的方式。

    在做路径分析时，会根据传入 `require` 方法中的模块标识符，做不同的处理：
    - 核心模块，如 `http`、`net` 等，在 `node` 源代码编译过程中已经被编译为二进制代码，加载速度最快；
    - 相对路径或者绝对路径的文件模块，会先解析为真实路径，然后将模块编译执行后的结果缓存到内存中，加载速度较快；
    - 非路径形式的文件模块，需要递归去 `node_modules` 下查找，加载速度最慢；

    `require` 在分析文件标识符时，如果标识符中不包含文件扩展名，`node` 会按照 `.js`、`.json`、`.node` 的次序依次补足扩展名，一一尝试。

    另外，在分析过程中，如果发现文件标识符是一个目录，`node` 会将目录当做一个包来处理，根据 `package.json` 中的 `main` 属性指定的文件名进行定位。如果不存在 `package.json` 文件或者没有 `main` 属性，则默认将当前目录下的 `index` 作为文件名，然后依次查找 `index.js`、`index.json`、`index.node`。

    定位到具体的文件以后，node 会新建一个模块对象，然后根据路径载入并编译。

    不同的文件名，载入方式也不相同:
    - `.js` 文件，通过 `fs` 模块同步读取文件后编译执行
    - `.node` 文件，通过 `C/C++` 编写的扩展文件，通过 `dlopen` 方法加载然后编译执行？？
    - `.json` 文件，通过 `fs` 模块同步读取文件后，用 `JSON.parse()` 解析返回结果
    - 其他文件，会被当做 `.js` 文件载入；

    核心模块、C/C++ 扩展模块的引入、编译、执行 ？？


5. `commonjs` 模块里面的 `module.exports`、`exports`、`__filename`、`__dirname` 怎么理解？

    在编译过程中，node 会对获取的 javascript 文件进行头尾包装，在头部添加 `(function(exports, require, module, __filename, __dirname) {`, 在尾部添加 `\n}`，然后通过类似 `eval` 的方式执行 `js` 代码。

6. `commonjs` 的包规范

    `commonjs` 的包规范也非常简单，分为两个部分: 包结构和包描述文件。

    包实际上是一个存档文件，即一个目录直接打包为 `.zip` 或者 `tar.gz` 格式的文件，安装后解压还原为目录。

    完全符合 `commonjs` 规范的包，应该包含一下文件:
    - `package.json`， 包描述文件；
    - `bin`, 用于存储可执行二进制文件的目录；
    - `lib`, 用于存放 javascript 代码的目录;
    - `doc`, 用于存放文档的目录；
    - `test`，用于存放单元测试用例的代码；

    包描述文件 `package.json` 的常用字段:
    - `name`, 包名;
    - `description`, 包简介；
    - `version`, 包版本号；
    - `keywords`, 关键词数组，主要用来做分类搜索，一个好的关键词数组有利于用户可以快速找到自己编写的包；
    - `maintainers`，包维护者列表；
    - `contributors`，贡献者列表；
    - `bugs`，一个可以反馈 bug 的网页地址或者邮箱地址；
    - `dependences`，当前包所需要依赖的包列表，这个属性非常重要，npm 会通过这个属性自动加载依赖的包；
    - `devDependencies`，开发依赖，npm 不会自动加载，需要开发人员自己手动下载；
    - `peerDependencies`，当开发一些插件和工具包时，对使用方的运行环境的依赖包版本有要求，可以使用 `peerDependencies` 字段进行声明;
    - `scripts`, 脚本说明对象；
    - `bin`，当我们希望包可以作为命令行工具使用时，可以配置 bin 字段。配置好 bin 字段以后，包在安装的时候会自动将脚本添加到执行路径中。如果是全局安装，会添加到全局环境中；如果是局部安装，会添加到项目的 node_modules/.bin 目录中。
    - `files`, 声明 `npm publish` 时要上传的文件，如果未指定，默认上传当前文件夹下的全部文件。我们可以在包的根目录或子目录中提供 .npmignore 文件，以防止某些文件被发布。.npmignore 文件的工作原理与.gitignore 一样。如果存在.gitignore 文件，而缺少.npmignore，则将改用.gitignore 的内容。files字段内容会覆盖.npmignore 和.gitignore的内容。
    - `private`，和发布 `npm` 包相关，如果为 `ture`，`npm` 会拒绝发布；
    - `main`, 定义包的入口文件，`browser` 环境和 `node` 环境均可使用；
    - `module`，定义包的符合 `ESM` 规范的入口文件，`broser` 环境和 `node` 环境均可使用；
    - `browser`，定义包在 `browser` 环境下的入口文件；
    - `type`， 包遵循的模块化规范，默认 `commonjs`；
    - `types`, 对外暴露 typescript 相关的类型定义；
    - `workspaces`, `monorepo` 开发时使用；

7. 依赖包全局安装模式

    全局模式安装:

    ```
    npm install xxx -g
    ```

    `-g` 是将一个包安装为全局可用的可执行文件。假如可执行文件的位置是 `/usr/local/bin/webpack`, 那么模块的目录就是 `/usr/local/lib/node_modules/webpack`, 然后通过软链接的方式，将 `bin` 字段配置的可执行文件链接到 `/usr/local/bin` 目录下。

8. 异步 `I/O`

    `node` 既可以作为服务器去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用发起并发请求。

    `Web` 的含义是网，而 `node` 的表现正如它的名字一样，是网络中一个灵活的节点。

    异步 `I/O` 在 `node` 里面是如此重要，与 `node` 面向网络的设计有很大的关系。

    `I/O` 是昂贵的，而分布式 `I/O` 更加昂贵。这就是异步 `I/0` 在 `node` 中盛行的原因, 因为异步获取资源，比同步获取资源消耗更少。而且随着应用规模的扩大，这用优势会越来越明显。

    `node` 相比其他语言，通过异步 `I/O`，能更快的响应资源，让前端的体验变好？？

    `node` 的优势:
    - 利用单线程，远离多线程死锁、状态同步问题；
    - 利用异步 `I/O`, 让单线程远离阻塞，以更好的使用 `CPU`；
    - 利用 `child_process`， 更高效的利用 `CPU` 和 `I/O`;

    `node` 的异步 `I/O` 是基于 `event loop` 实现的。

    `event loop` 是一个典型的生产者/消费者模型。异步 `I/O`、网络请求等是事件的生产者，源源不断的为 `node` 提供不同类型的事件，这些事件会传递到观察者那里， `event loop` 则从观察者那里取出事件来处理。

    `node` 实现高性能服务器：异步 `I/O` + 事件驱动(轮询);

9. 异步编程

    函数式编程:
    - 函数是一等公民，可以调用、可以作为函数入参、也可以作为函数返回值。
    - 异步编程与函数式编程的关系？？: 或者可以理解为，正式因为函数可以作为参数，也可以作为返回值，所以才能异步编程？？
    - 高阶函数: 可以把函数作为入参，也可以把函数作为返回值，如 `forEach`、`map`、`reduce` 等方法。
    - 偏函数: 通过指定部分参数，产生一个新的定制函数的用法。

    `node` 的灵魂所在: 基于事件驱动的非阻塞 `I/O` 模型。
    
    非阻塞 `I/O`，可以使 `CPU` 和 `I/O` 不需要相互依赖等待，让资源得到更好的利用。对于网络应用而言，并行带来的想象空间更大，延展而开就是分布式和云。并行使得各个单点之间能够更加有效的组织起来，这也是 `Node` 在云计算产商中广受青睐的原因。(现在是这样吗？？)

    只要合理利用 `node` 的异步模型与 `V8` 的高性能，就可以充分发挥 `CPU` 和 `I/O` 资源的优势。

    异步编程的难点:
    - 异常处理；
    - 函数嵌套过深；
    - 无法阻塞代码；
    - 无法多线程编码(这个可以使用 `child_process`， `cluster` 来解决这个问题)；
    - 异步转同步；

    异步编程的解决方案:
    - 事件发布/订阅模式；
    - promise
    - async / await, generator ??

    异步编程的并发控制？？


10. `node` 的内存控制

    `V8` 的垃圾回收机制和内存限制:
    - `node` 通过 `javascript` 使用内存时，只能使用部分内存(`64` 位操作系统只能使用 `1.4 GB`，`32` 位系统只能使用 `0.7 GB`，现在也如此吗？)；
    - 在 `V8` 中，所有的 `javascript` 对象都是通过 `heap` 来分配内存的。当我们在代码中声明变量并赋值时，所使用的对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 `V8` 限制为止。之所以要做限制，主要是因为垃圾回收机制。如果堆空间较大，每次做垃圾回收时都要消耗较长的时间，会导致 `javascript` 线程会暂停执行，影响性能和用户体验。
    - 打开内存限制 - 配置 `--max-old-space-size` 或者 `--max-new-space-size`, 需要在应用启动时设置，不能根据实际情况自动扩充。
    - 在 `V8` 中，主要将内存分为新生代和老生代两类，其中，新生代中存储存活时间较短的对象，老生代中存储存活时间较长的对象。`V8` 堆的整体大小就是新生代所用的内存空间 + 老生代所用的内存空间。
  
    新生代垃圾回收算法：
    - 是通过复制的方式实现的，即将堆内存空间一分为二，一个处于使用中，一个处于闲置状态。处于使用状态中的空间，称为 `from` 空间，处于闲置状态的空间，称为 `to` 空间。当开始垃圾回收时，会检查 `from` 空间中存活的对象，然后将存活对象复制到 `to` 空间中，将 `from` 空间中非存活对象占据的空间释放掉。完成复制以后，`from` 空间和 `to` 空间的角色完成对换。
    - 优点: 实现简单、快，由于新生代中对象的存活时间较短，适合这个算法;
    - 缺点:
      - 只能利用堆空间的一半；
      - 典型的空间获取时间的算法，无法大规模的应用到所有的垃圾回收中;


    实际使用的堆内存：新生代 `from` 空间 + 新生代 `to` 空间 + 老生代所用空间。

    新生代、老生代怎么确定: 当一个对象经过多次复制依然存活时，将被认为是生命周期较长的对象，会被移动到老生代中，称为晋升。

    对象晋升的条件:
    - 是否经历过新生代垃圾回收算法回收。从 `from` 空间移动到 `to` 空间时，会检查是否已经经历过一次回收，如果有，会把对象赋值到老生代空间中。
    - to 空间的内存占用比是否超出限制。从 `from` 空间移动到 `to` 空间时，如果 `to` 空间已经被占据 `25%`，直接将对象移动到老生代空间中。

    老生代垃圾回收不采用复制方法的原因:
    - 老生代收集的对象，生命周期较长，再采用复制的方法，效率较低；
    - 浪费一半空间；

    老生代垃圾回收采用标记清除 + 标记整理的算法:
    - 整个算法分为两个阶段，标记阶段和整理(清除)阶段；
    - 标记阶段，遍历堆中的所有对象，并标记活着的对象；
    - 标记完成以后，清除没有标记的对象；
    - 当空间不足以对新生代中晋升过来对象分配内存时，将活着的对象往一方移动；

    全停顿: 在进行垃圾回收时，应用逻辑会先暂停，等到垃圾挥手完成以后，才会恢复执行应用逻辑。这种情况下，新生代垃圾回收影响不大，老生代垃圾会后影响较大。

    为了降低全堆垃圾回收带来的停顿，`V8` 引入了增量标记、延迟清理、增量整理。

    从 `V8` 自动垃圾回收机制的设计角度可以看到，`V8` 对内存使用进行限制的缘由:
    - 新生代设置为一个较小的内存空间是合理的(方便复制)；
    - 老生代设置过大的空间并没有意义；

    想要高性能的执行效率，特别要注意让垃圾回收尽量少执行，尤其是全堆垃圾回收。

    在正常的 `javascript` 执行中，无法立即回收内存的情况:闭包和全局变量引用。由于 V8 的内存限制，要十分小心这类变量是否无限制的增加，导致新生代中的对象增多。

    查看内存的使用情况:
    - `process.memoryUsage()`, 查看 node 进程的内存占用情况；
    - `os.totalmem()`, `os.freemem()`，查看操作系统的内存占用情况；

    `node` 的内存构成: `V8` 进行分配的部分 + `node` 自行分配的部分。

    造成内存泄漏的原因:
    - 缓存，如使用普通对象作为缓存，可以改为 `map` 或者 `redis` 等；
    - 消息队列消费不及时，可以设置一个超时机制；
    - 作用域未释放；

    如果遇到操作大文件的情形，要使用 `stream`。

    
  

11. `Buffer`

    在 `node` 中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还需要处理大量二进制数据，`javascript` 自有的字符串远远不能满足需求， `buffer` 对象应用而生。

    `buffer` 是一个像 `Array` 的对象，但它主要用于操作字节。

    `buffer` 是一个典型的 `javascript` 与 `c++` 结合的模块，它将性能部分使用 `c++` 实现，非性能部分使用 `javascript` 实现。

    > `buffer` 需要专门找搞懂。

12. 网络编程

    `node` 提供了 `net`、`dgram`、`http`、`https` 四个模块，分别用于处理 `TCP`、`UDP`、`HTTP`、`HTTPS`, 适用于服务端和客户端。

    `TCP`, 全名传输控制协议，在 `OSI` 七层协议中属于传输层协议。很多应用层协议都是基于 `TCP` 构建的，典型的有 `HTTP`、`SMTP`、`IMAP` 等协议。

    `TCP` 是面向连接的协议，其显著的特征是在传输之前需要完成 `3` 次握手才可以形成会话。只有会话形成以后，服务端和客户端之间才可以完成通过。

    `UDP` 又称用户数据包协议，和 `TCP` 一样属于网络层协议。`UDP` 和 `TCP` 最大的不同是 `UDP` 不是面向连接的，一个套接字可以和多个 `UDP` 服务通信，属于不可靠信息传输。

13. 构建 `web` 应用

    使用 `node` 来构建 `web` 应用,这样前后端都采用 `javascript` 语言，在跨越 `http` 进行沟通时，会有一些额外的好处:
    - 不需要切换语言环境，上下文一致性较好；
    - 数据可以很好的实现跨前后端直接使用；
    - 一些业务可以很自由很轻量的选择是在前端还是在后端进行，切换代价小；

    构建 `web` 应用，需要用到 `http`、`https` 模块。

    鉴权:
    - cookie;
    - session;
    - token;
    - 其他;

14. 认证、授权、鉴权

    认证: 根据访问者所持有的识别信息，确认访问者的身份，如根据访问者提供的用户名 + 密码、手机验证码、指纹、语音、眼睛虹膜、面部，确认身份。

    授权: 赋予访问者指定范围内的操作权限，以便对资源进行相关操作，如给访问者赋予 `cookie`、`session`、`token`;

    鉴权: 对访问者进行鉴别确认的过程，如确认访问者提供的 `cookie`、`session`、`token` 是否有效。











问题收集:
- 函数式编程 ？？
- 异步编程和函数式编程有什么关系？？
- node 目前在分布式、云中的应用场景怎么样？？
- 异步编程相关知识整理，主要包括事件、promise、async / await、generator ??
- node 通过 javascript 使用内存时，内存限制是怎么样的？当前
- buffer 怎么使用？？


















