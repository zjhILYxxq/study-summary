#### node 相关

1. `node` 为什么要选择 `javascript` 作为实现语言？

    `node` 的作者以前的工作都是围绕高性能 `Web` 服务器进行的。

    设计高性能 `Web` 服务器的要点: 事件驱动、非阻塞 `I/O`。

    `node` 的作者最开始的目标是想写一个基于事件驱动、非阻塞 `I/O` 的 `Web` 服务器，还要没有历史负担，综合考虑下 `javascript` 比较合适。

2. `node` 的特点

    异步 `I/O`: `node` 中，绝大多数的操作都是以异步的方式调用。

    事件与回调函数

    单线程: 好处是不需要像多线编程一样处处在意状态同步问题，缺点是无法利用多核 `CPU`、应用的健壮性差(错误会引起整个程序退出)、大量计算会占用 `CPU` 导致无法继续调用异步 `I/0`。 大计算量的问题，可以通过 `Web Worker` 和 `child_process` 来解决。

    跨平台: 通过 `libuv` 可以实现跨平台。

3. `node` 的应用场景

    I/O 密集型，主要归功于事件循环的处理能力。

    CPU 密集型也可以借助 child_process 及合理的调度实现。

    分布式应用 + 和遗留系统和平共处

4. `node` 的模块机制

    `javascript` 先天缺乏一项功能: 模块机制。

    `commonjs` 规范的提出，主要是为了弥补 `javascript` 的缺陷，以达到像 `Java`、`Ruby`、`Pyhon` 等一样具备开发大型应用的能力，而不仅仅停留在小脚本程序的阶段。其中涵盖了模块、二进制 `buffer`、字符集编码、`I/O` 流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

    在 `node` 中引入模块，需要经历以下 `3` 个步骤:
    - 路径分析
    - 文件定位
    - 编译执行

    在 `node` 中，模块分为两类:
    - `node` 提供的模块，称为核心模块。在 node 进程启动时，部分核心模块就已经加载进内存中了，所以这部分模块在引入时，文件定位和编译执行步骤可以省略掉，并且在路径分析中优先判断，加载速度最快。
    - 用户自己编写的模块，称为文件模块。这类型的模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行，速度要比核心模块慢。

    不管是核心模块还是文件模块，`require` 方法对相同模块的二次加载都一律采用缓存优先的方式。

    在做路径分析时，会根据传入 `require` 方法中的模块标识符，做不同的处理：
    - 核心模块，如 `http`、`net` 等，在 `node` 源代码编译过程中已经被编译为二进制代码，加载速度最快；
    - 相对路径或者绝对路径的文件模块，会先解析为真实路径，然后将模块编译执行后的结果缓存到内存中，加载速度较快；
    - 非路径形式的文件模块，需要递归去 `node_modules` 下查找，加载速度最慢；

    `require` 在分析文件标识符时，如果标识符中不包含文件扩展名，`node` 会按照 `.js`、`.json`、`.node` 的次序依次补足扩展名，一一尝试。

    另外，在分析过程中，如果发现文件标识符是一个目录，`node` 会将目录当做一个包来处理，根据 `package.json` 中的 `main` 属性指定的文件名进行定位。如果不存在 `package.json` 文件或者没有 `main` 属性，则默认将当前目录下的 `index` 作为文件名，然后依次查找 `index.js`、`index.json`、`index.node`。

    定位到具体的文件以后，node 会新建一个模块对象，然后根据路径载入并编译。

    不同的文件名，载入方式也不相同:
    - `.js` 文件，通过 `fs` 模块同步读取文件后编译执行
    - `.node` 文件，通过 `C/C++` 编写的扩展文件，通过 `dlopen` 方法加载然后编译执行？？
    - `.json` 文件，通过 `fs` 模块同步读取文件后，用 `JSON.parse()` 解析返回结果
    - 其他文件，会被当做 `.js` 文件载入；

    核心模块、C/C++ 扩展模块的引入、编译、执行 ？？


5. `commonjs` 模块里面的 `module.exports`、`exports`、`__filename`、`__dirname` 怎么理解？

    在编译过程中，node 会对获取的 javascript 文件进行头尾包装，在头部添加 `(function(exports, require, module, __filename, __dirname) {`, 在尾部添加 `\n}`，然后通过类似 `eval` 的方式执行 `js` 代码。






