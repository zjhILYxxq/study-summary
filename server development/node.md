#### node 相关

1. `node` 为什么要选择 `javascript` 作为实现语言？

    `node` 的作者以前的工作都是围绕高性能 `Web` 服务器进行的。

    设计高性能 `Web` 服务器的要点: 事件驱动、非阻塞 `I/O`。

    `node` 的作者最开始的目标是想写一个基于事件驱动、非阻塞 `I/O` 的 `Web` 服务器，还要没有历史负担，综合考虑下 `javascript` 比较合适。

2. `node` 的特点

    异步 `I/O`: `node` 中，绝大多数的操作都是以异步的方式调用。

    事件与回调函数

    单线程: 好处是不需要像多线编程一样处处在意状态同步问题，缺点是无法利用多核 `CPU`、应用的健壮性差(错误会引起整个程序退出)、大量计算会占用 `CPU` 导致无法继续调用异步 `I/0`。 大计算量的问题，可以通过 `Web Worker` 和 `child_process` 来解决。

    跨平台: 通过 `libuv` 可以实现跨平台。

3. `node` 的应用场景

    I/O 密集型，主要归功于事件循环的处理能力。

    CPU 密集型也可以借助 child_process 及合理的调度实现。

    分布式应用 + 和遗留系统和平共处

4. `node` 的模块机制

    `javascript` 先天缺乏一项功能: 模块机制。

    `commonjs` 规范的提出，主要是为了弥补 `javascript` 的缺陷，以达到像 `Java`、`Ruby`、`Pyhon` 等一样具备开发大型应用的能力，而不仅仅停留在小脚本程序的阶段。其中涵盖了模块、二进制 `buffer`、字符集编码、`I/O` 流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

    在 `node` 中引入模块，需要经历以下 `3` 个步骤:
    - 路径分析
    - 文件定位
    - 编译执行

    在 `node` 中，模块分为两类:
    - `node` 提供的模块，称为核心模块。在 node 进程启动时，部分核心模块就已经加载进内存中了，所以这部分模块在引入时，文件定位和编译执行步骤可以省略掉，并且在路径分析中优先判断，加载速度最快。
    - 用户自己编写的模块，称为文件模块。这类型的模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行，速度要比核心模块慢。

    不管是核心模块还是文件模块，`require` 方法对相同模块的二次加载都一律采用缓存优先的方式。

    在做路径分析时，会根据传入 `require` 方法中的模块标识符，做不同的处理：
    - 核心模块，如 `http`、`net` 等，在 `node` 源代码编译过程中已经被编译为二进制代码，加载速度最快；
    - 相对路径或者绝对路径的文件模块，会先解析为真实路径，然后将模块编译执行后的结果缓存到内存中，加载速度较快；
    - 非路径形式的文件模块，需要递归去 `node_modules` 下查找，加载速度最慢；

    `require` 在分析文件标识符时，如果标识符中不包含文件扩展名，`node` 会按照 `.js`、`.json`、`.node` 的次序依次补足扩展名，一一尝试。

    另外，在分析过程中，如果发现文件标识符是一个目录，`node` 会将目录当做一个包来处理，根据 `package.json` 中的 `main` 属性指定的文件名进行定位。如果不存在 `package.json` 文件或者没有 `main` 属性，则默认将当前目录下的 `index` 作为文件名，然后依次查找 `index.js`、`index.json`、`index.node`。

    定位到具体的文件以后，node 会新建一个模块对象，然后根据路径载入并编译。

    不同的文件名，载入方式也不相同:
    - `.js` 文件，通过 `fs` 模块同步读取文件后编译执行
    - `.node` 文件，通过 `C/C++` 编写的扩展文件，通过 `dlopen` 方法加载然后编译执行？？
    - `.json` 文件，通过 `fs` 模块同步读取文件后，用 `JSON.parse()` 解析返回结果
    - 其他文件，会被当做 `.js` 文件载入；

    核心模块、C/C++ 扩展模块的引入、编译、执行 ？？


5. `commonjs` 模块里面的 `module.exports`、`exports`、`__filename`、`__dirname` 怎么理解？

    在编译过程中，node 会对获取的 javascript 文件进行头尾包装，在头部添加 `(function(exports, require, module, __filename, __dirname) {`, 在尾部添加 `\n}`，然后通过类似 `eval` 的方式执行 `js` 代码。

6. `commonjs` 的包规范

    `commonjs` 的包规范也非常简单，分为两个部分: 包结构和包描述文件。

    包实际上是一个存档文件，即一个目录直接打包为 `.zip` 或者 `tar.gz` 格式的文件，安装后解压还原为目录。

    完全符合 `commonjs` 规范的包，应该包含一下文件:
    - `package.json`， 包描述文件；
    - `bin`, 用于存储可执行二进制文件的目录；
    - `lib`, 用于存放 javascript 代码的目录;
    - `doc`, 用于存放文档的目录；
    - `test`，用于存放单元测试用例的代码；

    包描述文件 `package.json` 的常用字段:
    - `name`, 包名;
    - `description`, 包简介；
    - `version`, 包版本号；
    - `keywords`, 关键词数组，主要用来做分类搜索，一个好的关键词数组有利于用户可以快速找到自己编写的包；
    - `maintainers`，包维护者列表；
    - `contributors`，贡献者列表；
    - `bugs`，一个可以反馈 bug 的网页地址或者邮箱地址；
    - `dependences`，当前包所需要依赖的包列表，这个属性非常重要，npm 会通过这个属性自动加载依赖的包；
    - `devDependencies`，开发依赖，npm 不会自动加载，需要开发人员自己手动下载；
    - `peerDependencies`，当开发一些插件和工具包时，对使用方的运行环境的依赖包版本有要求，可以使用 `peerDependencies` 字段进行声明;
    - `scripts`, 脚本说明对象；
    - `bin`，当我们希望包可以作为命令行工具使用时，可以配置 bin 字段。配置好 bin 字段以后，包在安装的时候会自动将脚本添加到执行路径中。如果是全局安装，会添加到全局环境中；如果是局部安装，会添加到项目的 node_modules/.bin 目录中。
    - `files`, 声明 `npm publish` 时要上传的文件，如果未指定，默认上传当前文件夹下的全部文件。我们可以在包的根目录或子目录中提供 .npmignore 文件，以防止某些文件被发布。.npmignore 文件的工作原理与.gitignore 一样。如果存在.gitignore 文件，而缺少.npmignore，则将改用.gitignore 的内容。files字段内容会覆盖.npmignore 和.gitignore的内容。
    - `private`，和发布 `npm` 包相关，如果为 `ture`，`npm` 会拒绝发布；
    - `main`, 定义包的入口文件，`browser` 环境和 `node` 环境均可使用；
    - `module`，定义包的符合 `ESM` 规范的入口文件，`broser` 环境和 `node` 环境均可使用；
    - `browser`，定义包在 `browser` 环境下的入口文件；
    - `type`， 包遵循的模块化规范，默认 `commonjs`；
    - `types`, 对外暴露 typescript 相关的类型定义；
    - `workspaces`, `monorepo` 开发时使用；

7. 依赖包全局安装模式

    全局模式安装:

    ```
    npm install xxx -g
    ```

    `-g` 是将一个包安装为全局可用的可执行文件。假如可执行文件的位置是 `/usr/local/bin/webpack`, 那么模块的目录就是 `/usr/local/lib/node_modules/webpack`, 然后通过软链接的方式，将 `bin` 字段配置的可执行文件链接到 `/usr/local/bin` 目录下。

8. 异步 `I/O`

    `node` 既可以作为服务器去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用发起并发请求。

    `Web` 的含义是网，而 `node` 的表现正如它的名字一样，是网络中一个灵活的节点。

    异步 `I/O` 在 `node` 里面是如此重要，与 `node` 面向网络的设计有很大的关系。

    `I/O` 是昂贵的，而分布式 `I/O` 更加昂贵。这就是异步 `I/0` 在 `node` 中盛行的原因, 因为异步获取资源，比同步获取资源消耗更少。而且随着应用规模的扩大，这用优势会越来越明显。

    `node` 相比其他语言，通过异步 `I/O`，能更快的响应资源，让前端的体验变好？？

    `node` 的优势:
    - 利用单线程，远离多线程死锁、状态同步问题；
    - 利用异步 `I/O`, 让单线程远离阻塞，以更好的使用 `CPU`；
    - 利用 `child_process`， 更高效的利用 `CPU` 和 `I/O`;

    `node` 的异步 `I/O` 是基于 `event loop` 实现的。

    `event loop` 是一个典型的生产者/消费者模型。异步 `I/O`、网络请求等是事件的生产者，源源不断的为 `node` 提供不同类型的事件，这些事件会传递到观察者那里， `event loop` 则从观察者那里取出事件来处理。

    `node` 实现高性能服务器：异步 `I/O` + 事件驱动(轮询);

9. 异步编程

    函数式编程:
    - 函数是一等公民，可以调用、可以作为函数入参、也可以作为函数返回值。
    - 异步编程与函数式编程的关系？？: 或者可以理解为，正式因为函数可以作为参数，也可以作为返回值，所以才能异步编程？？
    - 高阶函数: 可以把函数作为入参，也可以把函数作为返回值，如 `forEach`、`map`、`reduce` 等方法。
    - 偏函数: 通过指定部分参数，产生一个新的定制函数的用法。

    `node` 的灵魂所在: 基于事件驱动的非阻塞 `I/O` 模型。
    
    非阻塞 `I/O`，可以使 `CPU` 和 `I/O` 不需要相互依赖等待，让资源得到更好的利用。对于网络应用而言，并行带来的想象空间更大，延展而开就是分布式和云。并行使得各个单点之间能够更加有效的组织起来，这也是 `Node` 在云计算产商中广受青睐的原因。(现在是这样吗？？)

    只要合理利用 `node` 的异步模型与 `V8` 的高性能，就可以充分发挥 `CPU` 和 `I/O` 资源的优势。

    异步编程的难点:
    - 异常处理；
    - 函数嵌套过深；
    - 无法阻塞代码；
    - 无法多线程编码(这个可以使用 `child_process`， `cluster` 来解决这个问题)；
    - 异步转同步；

    异步编程的解决方案:
    - 事件发布/订阅模式；
    - promise
    - async / await, generator ??

    异步编程的并发控制？？


10. `node` 的内存控制

    `V8` 的垃圾回收机制和内存限制:
    - `node` 通过 `javascript` 使用内存时，只能使用部分内存(`64` 位操作系统只能使用 `1.4 GB`，`32` 位系统只能使用 `0.7 GB`，现在也如此吗？)；
    - 在 `V8` 中，所有的 `javascript` 对象都是通过 `heap` 来分配内存的。当我们在代码中声明变量并赋值时，所使用的对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 `V8` 限制为止。之所以要做限制，主要是因为垃圾回收机制。如果堆空间较大，每次做垃圾回收时都要消耗较长的时间，会导致 `javascript` 线程会暂停执行，影响性能和用户体验。
    - 打开内存限制 - 配置 `--max-old-space-size` 或者 `--max-new-space-size`, 需要在应用启动时设置，不能根据实际情况自动扩充。
    - 在 `V8` 中，主要将内存分为新生代和老生代两类，其中，新生代中存储存活时间较短的对象，老生代中存储存活时间较长的对象。`V8` 堆的整体大小就是新生代所用的内存空间 + 老生代所用的内存空间。
  
    新生代垃圾回收算法：
    - 是通过复制的方式实现的，即将堆内存空间一分为二，一个处于使用中，一个处于闲置状态。处于使用状态中的空间，称为 `from` 空间，处于闲置状态的空间，称为 `to` 空间。当开始垃圾回收时，会检查 `from` 空间中存活的对象，然后将存活对象复制到 `to` 空间中，将 `from` 空间中非存活对象占据的空间释放掉。完成复制以后，`from` 空间和 `to` 空间的角色完成对换。
    - 优点: 实现简单、快，由于新生代中对象的存活时间较短，适合这个算法;
    - 缺点:
      - 只能利用堆空间的一半；
      - 典型的空间获取时间的算法，无法大规模的应用到所有的垃圾回收中;


    实际使用的堆内存：新生代 `from` 空间 + 新生代 `to` 空间 + 老生代所用空间。

    新生代、老生代怎么确定: 当一个对象经过多次复制依然存活时，将被认为是生命周期较长的对象，会被移动到老生代中，称为晋升。

    对象晋升的条件:
    - 是否经历过新生代垃圾回收算法回收。从 `from` 空间移动到 `to` 空间时，会检查是否已经经历过一次回收，如果有，会把对象赋值到老生代空间中。
    - to 空间的内存占用比是否超出限制。从 `from` 空间移动到 `to` 空间时，如果 `to` 空间已经被占据 `25%`，直接将对象移动到老生代空间中。

    老生代垃圾回收不采用复制方法的原因:
    - 老生代收集的对象，生命周期较长，再采用复制的方法，效率较低；
    - 浪费一半空间；

    老生代垃圾回收采用标记清除 + 标记整理的算法:
    - 整个算法分为两个阶段，标记阶段和整理(清除)阶段；
    - 标记阶段，遍历堆中的所有对象，并标记活着的对象；
    - 标记完成以后，清除没有标记的对象；
    - 当空间不足以对新生代中晋升过来对象分配内存时，将活着的对象往一方移动；

    全停顿: 在进行垃圾回收时，应用逻辑会先暂停，等到垃圾挥手完成以后，才会恢复执行应用逻辑。这种情况下，新生代垃圾回收影响不大，老生代垃圾会后影响较大。

    为了降低全堆垃圾回收带来的停顿，`V8` 引入了增量标记、延迟清理、增量整理。

    从 `V8` 自动垃圾回收机制的设计角度可以看到，`V8` 对内存使用进行限制的缘由:
    - 新生代设置为一个较小的内存空间是合理的(方便复制)；
    - 老生代设置过大的空间并没有意义；

    想要高性能的执行效率，特别要注意让垃圾回收尽量少执行，尤其是全堆垃圾回收。

    在正常的 `javascript` 执行中，无法立即回收内存的情况:闭包和全局变量引用。由于 V8 的内存限制，要十分小心这类变量是否无限制的增加，导致新生代中的对象增多。

    查看内存的使用情况:
    - `process.memoryUsage()`, 查看 node 进程的内存占用情况；
    - `os.totalmem()`, `os.freemem()`，查看操作系统的内存占用情况；

    `node` 的内存构成: `V8` 进行分配的部分 + `node` 自行分配的部分。

    造成内存泄漏的原因:
    - 缓存，如使用普通对象作为缓存，可以改为 `map` 或者 `redis` 等；
    - 消息队列消费不及时，可以设置一个超时机制；
    - 作用域未释放；

    如果遇到操作大文件的情形，要使用 `stream`。

    
  

11. `Buffer`

    在 `node` 中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还需要处理大量二进制数据，`javascript` 自有的字符串远远不能满足需求， `buffer` 对象应用而生。

    `buffer` 是一个像 `Array` 的对象，但它主要用于操作字节。

    `buffer` 是一个典型的 `javascript` 与 `c++` 结合的模块，它将性能部分使用 `c++` 实现，非性能部分使用 `javascript` 实现。

    > `buffer` 需要专门找搞懂。

12. 网络编程

    `node` 提供了 `net`、`dgram`、`http`、`https` 四个模块，分别用于处理 `TCP`、`UDP`、`HTTP`、`HTTPS`, 适用于服务端和客户端。

    `TCP`, 全名传输控制协议，在 `OSI` 七层协议中属于传输层协议。很多应用层协议都是基于 `TCP` 构建的，典型的有 `HTTP`、`SMTP`、`IMAP` 等协议。

    `TCP` 是面向连接的协议，其显著的特征是在传输之前需要完成 `3` 次握手才可以形成会话。只有会话形成以后，服务端和客户端之间才可以完成通过。

    `UDP` 又称用户数据包协议，和 `TCP` 一样属于网络层协议。`UDP` 和 `TCP` 最大的不同是 `UDP` 不是面向连接的，一个套接字可以和多个 `UDP` 服务通信，属于不可靠信息传输。

13. 构建 `web` 应用

    使用 `node` 来构建 `web` 应用,这样前后端都采用 `javascript` 语言，在跨越 `http` 进行沟通时，会有一些额外的好处:
    - 不需要切换语言环境，上下文一致性较好；
    - 数据可以很好的实现跨前后端直接使用；
    - 一些业务可以很自由很轻量的选择是在前端还是在后端进行，切换代价小；

    构建 `web` 应用，需要用到 `http`、`https` 模块。

    鉴权:
    - cookie;
    - session;
    - token;
    - 其他;
  
    `http` 模块

14. 认证、授权、鉴权

    认证: 根据访问者所持有的识别信息，确认访问者的身份，如根据访问者提供的用户名 + 密码、手机验证码、指纹、语音、眼睛虹膜、面部，确认身份。

    授权: 赋予访问者指定范围内的操作权限，以便对资源进行相关操作，如给访问者赋予 `cookie`、`session`、`token`;

    鉴权: 对访问者进行鉴别确认的过程，如确认访问者提供的 `cookie`、`session`、`token` 是否有效。

    常用的鉴权方案:

    - `http` 基本鉴权(`Basic Access Authentication` - 基本认证方案)
        
        整个鉴权过程:
        1. 客户端向浏览器请求一个受限资源；
        2. 服务端发现客户端未授权，向客户端返回 `401` 以及附带一个认证域 `www-Authentication` 字段，要求客户端进行身份验证；
        3. 客户端自动弹出一个弹窗，让用户输入用户名和密码，以 `base64` 的加密方式发送给服务端；
        4. 服务端进行验证，如果验证成功，返回需要的资源

        优点: 实现简单，所有的浏览器都支持。

        缺点: 
        - 不安全；
        - 无法主动注销；

        使用场景: 内部网络，或者对安全要求不高的网络。 

    - `Session`-`Cookie` 鉴权

        `http` 是无状态的协议, 每次客户端和服务端完成会话以后，服务端不会保存任何会话信息。

        为了能让服务端识别客户端，就需要客户端去维护一个状态，通过这个状态告知服务端多次请求是否来自同一个客户端。

        这个状态，可以通过 `Cookie` 实现。

        `Cookie` 是浏览器将服务端返回的数据保存在本地的一小块数据(大约 `4 KB`)。当服务端收到 `http` 请求时, 可以在响应头里面设置 `set-cookie` 字段。浏览器接收到响应之后会自动保存 `cookie`, 并在之后的每一次请求中都会自动在请求头中添加 `cookie` 字段，把 `cookie` 信息发送给服务器。

        

        设置 `cookie` 是的几个关键属性
        - `domain`, 指定哪些 `host` 可以接受 `cookie`, 如果 `domain` 和当前页面的 `host` 匹配，那么是 `first-part cookie`，否则是 `third-part cookie`；
        - `path`, 指定哪些 `url` 请求时可以携带 `cookie`, `domain` 和 `path` 定义了 `cookie` 的作用域，即允许 `cookie` 发送给哪些 `url`；
        - `HttpOnly`, 设置是否可以通过 `document.cookie` 来读写 `cookie`，可以用来预防 `xss` 攻击；
        - `Secure`，标记为 `Secure` 的 `Cookie` 只能通过被 `https` 协议加密过的请求发送给服务端；
        - `SameSite`, 设置是否可以在跨站点发送请求时携带第三方 `cookie`, 可以设置的值为 `strict`、`lax`、`none`。`strict` 最为严格，`cookie` 只能作为 `firsr-part cookie` 使用；`none` 最为宽松，`cookie` 可以作为 `first-part cookie`、`third-part cookie` 使用；`lax` 和 `strict` 类似，只会阻止在使用危险 `HTTP` 方法进行请求携带的三方 `Cookie`，例如 `POS`T 方式,同时，使用 `JavaScript` 脚本发起的请求也无法携带三方 `Cookie`。使用 `SameSite` 可以用来预防 `csrf` 攻击。
        - `SamePart`, 为了绕开浏览器对 `thirt-part cookie` 的限制，又不想使用 `same-sit:none`，这个时候可以使用 `same-part`。`same-part` 可以设置 `cookie` 在指定集合内不会当做 `third-part cookie`。具体实现参见: [same-part](https://juejin.cn/post/7002011181221167118)

        `cookie` 在顶级域名、二级域名、三级域名之间的共享情况:
        - 在 `set-cookie` 中省略 `domain`，那么 `domain` 默认为当前域名；
        - 在设置 `domain` 时，可以设置父域名以及自身，但不能设置子域名及其他域名，否则 `cookie` 不生效；
        - 如果 `domain` 设置为顶级域名, 则全部的域名包括顶级域名、二级域名、三级域名都可以访问 `cookie`；
        - 如果 `domain` 设置为当前域名，则当前域名、所有子域名都可以访问 `cookie`；

        使用 `cookie` 的缺点:
        - 大小限制，最大为 `4kb`；
        - 数量有限制；
        - 不安全；

        `Session`，服务器生成的一种数据结构，可以通过多种方式保存，如内存、数据库、文件等。

        简单来说，就是服务端生成一个 `session id`，然后保存到 `cookie` 中。等到客户端再次发起请求时，携带 `cookie` 信息，然后由服务端去解析 `cookie` 中的 `session id`，判断请求是否合法。

        `Session-Cookie` 的优点：
        - `cookie` 简单易用；
        - `session` 保存到服务端，方便新增删除，便于管理；

        `Session-Cookie` 的缺点：
        - 依赖 `cookie`, 不安全；
        - 存储在服务端，会增大服务端的开销； 

    - `Token`
        
        `Token` 是一个令牌。当客户端访问服务端时，服务端会根据用户名和密码为客户生成一个令牌，然后返回给客户端。客户端之后发起的请求都会携带这张令牌，服务端只需要验证令牌的有效性就可以了。

        `Token` 的组成: `uid`(用户唯一标识) + `time`(时间戳) + `sign`(加密算法生成)

        使用 `Token` 时，服务端不需要将 `Token` 存储，只不过需要每次进行验证？？(时间换空间)？

        使用 `Token` 时，可以不依赖 `cookie`。

        `Token` 的优点：
        - 服务端无状态话化、可扩展性好，便于在多个服务器之间共享状态(这一点最关键)；
        - 可以不依赖 `cookie`，安全性好，也可以跨程序调用；
        
        `Token` 的缺点:
        - 如果不依赖于 `cookie`，需要前端做手动处理；
        - 性能问题，服务端每次都需要验证？时间换空间？；
        - 有效期短？？

        为了安全，通常会把 `Access Token` 的有效期设置的较短，以避免被盗用。而过短的有效期又经常会导致 `Access Token` 失效。

        解决方案:
        - 刷新 `Access Token`，需要用户重新登录，比较麻烦。
        - 生成一个 `Refresh Token`，专门用来生成 `Access Token`, 有效期比 `Access Token` 要长。

            也比较好理解。

            当用户登录时，根据用户名、密码等信息生成一个 `Access Token` 和一个 `Refresh Token`。`Refresh Token` 的有效期比 `Access Token` 长。 当 `Access Token` 失效时，再根据 `Refresh Token` 生成一个新的 `Access Token`，然后重新发起请求。

        另外，服务端接收到客户端发起的请求以后，需要对 `Token` 进行验证, 这个时候需要获取用户基本信息，会存在读写数据库的操作。这对性能会造成影响。

        为了解决这个问题，有了 `JWT` - `JSON Web Token` 方式，即根据一个 `JSON` 生成 `Token`。`JSON` 中会包含用户信息、有效时间等。然后选择一定的加密算法，对 `JSON` 进行加密，然后返回给客户端。等服务端接收到客户端发起的请求以后，对 `Token` 进行解密。

        `JWT` 的优点：易于扩展，降低服务器的负载；

        `JWT` 的缺点: `token` 体积过大; 无法在使用过程中废除某个 `token`，必须要等 `token` 失效；

    - `Single Sign On` - 单点登录，即多个应用系统，只需要登录一次，就可以访问其他相互信任的系统。

        单点登录的情况：
        - 主域名相同，可以利用 `cookie` 实现单点登录；
        - 主域名不同，可以采用 `CAS - Centeral Authentication Service`，中央授权服务;

            `CAS` 方式解决单点登录问题，需要借助一个单独的 `CAS` 服务 + 重定向：
            1. 用户访问 `A`，发现没有登录，重定向到 `CAS` 服务，并携带 `redirectUrl`(`A` 的链接)；
            2. 用户访问 `CAS` 服务，发现没有登录，重定向到 `CAS` 提供的登录页；
            3. 用户登录，`CAS` 服务校验并将 `session / token` 保存到 `cookie` 中，域名为 `CAS` 服务对应的域名；
            4. 登录成功以后，重定向到 `A` 的 `url`，并携带 `token` 参数， `A` 登录成功；
            5. 用户访问 `B`，发现没有登录，重定向到 `CAS` 服务，并携带 `redirectUrl`(`B` 的链接)；
            6. 用户访问 `CAS` 服务，发现已经登录，重定向到 `B` 的 `url`，并携带 `token` 参数；
            7. `B` 登录成功；
          
    - `OAuth 2.0` - 授权认证 

        登录网站时，除了可以使用用户名、密码，还可以使用微信、`qq`。

        `OAuth` 是一个开放标准，允许用户授权第三方访问他们存储在另外的服务提供者上的信息，而不需要将用户名、密码提供给第三方。

        简单来说，就是 `OAuth` 是一种授权机制, 数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌 - `Token`，用来代替密码，供第三方使用。

        常见的用户场景 - 微信授权登录，即使用微信打开一个 `h5` 页面，然后需要做微信授权。这里的 `h5` 应用就是第三方应用，微信会为第三方 `h5` 应用生成一个短期的 `Token`。

        常见的提供 `OAuth` 认证服务的厂商: 支付宝、微信、`QQ`、微博。

        常见的授权过程:
        1. 打开站点 `A`，进入登录页面，选择授权登录，如微信；
        2. `A` 站点接收到请求以后，重定向到微信的授权登录页面，重定向 `url` 会携带一个 `redirect_uri` 参数；
        3. 完成微信认证(如扫码认证)，跳转到 `redirect_uri` 指定 `url`, 并携带微信认证返回的 `code`；
        4. `A` 站点获取到 `code` 以后, 在通过接口去微信拿 `Token` 及相关数据，然后将 `Token` 放在站点，把数据返回给客户端；

        > 更多详见: [OAuth 2.0](https://juejin.cn/post/7129298214959710244#heading-36) 

    - 联合登录 ？？
 
    - 信任登录 ？？
  

    - 唯一登录：禁止多人同时登录同一账号，后者的登录行为会导致前者下线。
  
        方案:
        - 客户端保存 token，后者登录以后，之前的 token 失效；
        - ws 推送；
    
    - 扫码登录 
        
        扫码登录的过程:
        1. `PC` 端打开某个站点，向服务端发起一个获取二维码的请求；
        2. 服务端返回一个二维码；
        3. `PC` 开始轮询二维码的状态；
        4. 用手机扫码，根据用户信息、二维码信息，获取一个临时 `Token`；
        5. 手机端点击确认，将临时 `Token` 发送给服务端，生成一个正式 `Token`，并更新二维码状态；
        6. PC 端通过轮询获取到正式 `Token` 和二维码状态；
    
    -  一键登录
        使用应用时，只要能获取到当前手机使用的手机号，就可以使用当前手机号进行登录，而不需要额外的操作，这就是一键登录。
        
        一键登录功能需要运营商开放相关服务, 即提供相关 `SDK`。

        一键登录的详细过程:
        1. `SDK` 初始化，即调用 `SDK` 方法，传入平台配置的 `AppKey` 和 `AppSecret`； 
        2. 唤起授权页，即调用 `SDK` 唤起授权接口。`SDK` 会先向运营商发起获取手机号掩码的请求，请求成功以后会跳转到授权页。授权页会显示手机号掩码以及运营商协议给用户确认。
        3. 同意授权并登录。用户同意相关协议，点击授权页面的登录按钮，`SDK` 会请求本次取号的 `Token`，请求成功以后会将 `Token` 返回给客户端。
        4. 将获取到的 `Token` 发送到自己的服务器，由服务端携带 `Token` 调用运营商一键登录的接口，调用成功就返回手机号码。服务端用手机号进行登录或注册操作，返回操作结果给客户端，完成一键登录。















问题收集:
- 函数式编程 ？？
- 异步编程和函数式编程有什么关系？？
- node 目前在分布式、云中的应用场景怎么样？？
- 异步编程相关知识整理，主要包括事件、promise、async / await、generator ??
- node 通过 javascript 使用内存时，内存限制是怎么样的？当前
- buffer 怎么使用？？


















