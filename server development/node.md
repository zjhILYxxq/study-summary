#### node 相关

1. `node` 为什么要选择 `javascript` 作为实现语言？

    `node` 的作者以前的工作都是围绕高性能 `Web` 服务器进行的。

    设计高性能 `Web` 服务器的要点: 事件驱动、非阻塞 `I/O`。

    `node` 的作者最开始的目标是想写一个基于事件驱动、非阻塞 `I/O` 的 `Web` 服务器，还要没有历史负担，综合考虑下 `javascript` 比较合适。

2. `node` 的特点

    异步 `I/O`: `node` 中，绝大多数的操作都是以异步的方式调用。

    事件与回调函数

    单线程: 好处是不需要像多线编程一样处处在意状态同步问题，缺点是无法利用多核 `CPU`、应用的健壮性差(错误会引起整个程序退出)、大量计算会占用 `CPU` 导致无法继续调用异步 `I/0`。 大计算量的问题，可以通过 `Web Worker` 和 `child_process` 来解决。

    跨平台: 通过 `libuv` 可以实现跨平台。

3. `node` 的应用场景

    I/O 密集型，主要归功于事件循环的处理能力。

    CPU 密集型也可以借助 child_process 及合理的调度实现。

    分布式应用 + 和遗留系统和平共处

4. `node` 的模块机制

    `javascript` 先天缺乏一项功能: 模块机制。

    `commonjs` 规范的提出，主要是为了弥补 `javascript` 的缺陷，以达到像 `Java`、`Ruby`、`Pyhon` 等一样具备开发大型应用的能力，而不仅仅停留在小脚本程序的阶段。其中涵盖了模块、二进制 `buffer`、字符集编码、`I/O` 流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

    在 `node` 中引入模块，需要经历以下 `3` 个步骤:
    - 路径分析
    - 文件定位
    - 编译执行

    在 `node` 中，模块分为两类:
    - `node` 提供的模块，称为核心模块。在 node 进程启动时，部分核心模块就已经加载进内存中了，所以这部分模块在引入时，文件定位和编译执行步骤可以省略掉，并且在路径分析中优先判断，加载速度最快。
    - 用户自己编写的模块，称为文件模块。这类型的模块是在运行时动态加载，需要完整的路径分析、文件定位、编译执行，速度要比核心模块慢。

    不管是核心模块还是文件模块，`require` 方法对相同模块的二次加载都一律采用缓存优先的方式。

    在做路径分析时，会根据传入 `require` 方法中的模块标识符，做不同的处理：
    - 核心模块，如 `http`、`net` 等，在 `node` 源代码编译过程中已经被编译为二进制代码，加载速度最快；
    - 相对路径或者绝对路径的文件模块，会先解析为真实路径，然后将模块编译执行后的结果缓存到内存中，加载速度较快；
    - 非路径形式的文件模块，需要递归去 `node_modules` 下查找，加载速度最慢；

    `require` 在分析文件标识符时，如果标识符中不包含文件扩展名，`node` 会按照 `.js`、`.json`、`.node` 的次序依次补足扩展名，一一尝试。

    另外，在分析过程中，如果发现文件标识符是一个目录，`node` 会将目录当做一个包来处理，根据 `package.json` 中的 `main` 属性指定的文件名进行定位。如果不存在 `package.json` 文件或者没有 `main` 属性，则默认将当前目录下的 `index` 作为文件名，然后依次查找 `index.js`、`index.json`、`index.node`。

    定位到具体的文件以后，node 会新建一个模块对象，然后根据路径载入并编译。

    不同的文件名，载入方式也不相同:
    - `.js` 文件，通过 `fs` 模块同步读取文件后编译执行
    - `.node` 文件，通过 `C/C++` 编写的扩展文件，通过 `dlopen` 方法加载然后编译执行？？
    - `.json` 文件，通过 `fs` 模块同步读取文件后，用 `JSON.parse()` 解析返回结果
    - 其他文件，会被当做 `.js` 文件载入；

    核心模块、C/C++ 扩展模块的引入、编译、执行 ？？


5. `commonjs` 模块里面的 `module.exports`、`exports`、`__filename`、`__dirname` 怎么理解？

    在编译过程中，node 会对获取的 javascript 文件进行头尾包装，在头部添加 `(function(exports, require, module, __filename, __dirname) {`, 在尾部添加 `\n}`，然后通过类似 `eval` 的方式执行 `js` 代码。

6. `commonjs` 的包规范

    `commonjs` 的包规范也非常简单，分为两个部分: 包结构和包描述文件。

    包实际上是一个存档文件，即一个目录直接打包为 `.zip` 或者 `tar.gz` 格式的文件，安装后解压还原为目录。

    完全符合 `commonjs` 规范的包，应该包含一下文件:
    - `package.json`， 包描述文件；
    - `bin`, 用于存储可执行二进制文件的目录；
    - `lib`, 用于存放 javascript 代码的目录;
    - `doc`, 用于存放文档的目录；
    - `test`，用于存放单元测试用例的代码；

    包描述文件 `package.json` 的常用字段:
    - `name`, 包名;
    - `description`, 包简介；
    - `version`, 包版本号；
    - `keywords`, 关键词数组，主要用来做分类搜索，一个好的关键词数组有利于用户可以快速找到自己编写的包；
    - `maintainers`，包维护者列表；
    - `contributors`，贡献者列表；
    - `bugs`，一个可以反馈 bug 的网页地址或者邮箱地址；
    - `dependences`，当前包所需要依赖的包列表，这个属性非常重要，npm 会通过这个属性自动加载依赖的包；
    - `devDependencies`，开发依赖，npm 不会自动加载，需要开发人员自己手动下载；
    - `peerDependencies`，当开发一些插件和工具包时，对使用方的运行环境的依赖包版本有要求，可以使用 `peerDependencies` 字段进行声明;
    - `scripts`, 脚本说明对象；
    - `bin`，当我们希望包可以作为命令行工具使用时，可以配置 bin 字段。配置好 bin 字段以后，包在安装的时候会自动将脚本添加到执行路径中。如果是全局安装，会添加到全局环境中；如果是局部安装，会添加到项目的 node_modules/.bin 目录中。
    - `files`, 声明 `npm publish` 时要上传的文件，如果未指定，默认上传当前文件夹下的全部文件。我们可以在包的根目录或子目录中提供 .npmignore 文件，以防止某些文件被发布。.npmignore 文件的工作原理与.gitignore 一样。如果存在.gitignore 文件，而缺少.npmignore，则将改用.gitignore 的内容。files字段内容会覆盖.npmignore 和.gitignore的内容。
    - `private`，和发布 `npm` 包相关，如果为 `ture`，`npm` 会拒绝发布；
    - `main`, 定义包的入口文件，`browser` 环境和 `node` 环境均可使用；
    - `module`，定义包的符合 `ESM` 规范的入口文件，`broser` 环境和 `node` 环境均可使用；
    - `browser`，定义包在 `browser` 环境下的入口文件；
    - `type`， 包遵循的模块化规范，默认 `commonjs`；
    - `types`, 对外暴露 typescript 相关的类型定义；
    - `workspaces`, `monorepo` 开发时使用；

7. 依赖包全局安装模式

    全局模式安装:

    ```
    npm install xxx -g
    ```

    `-g` 是将一个包安装为全局可用的可执行文件。假如可执行文件的位置是 `/usr/local/bin/webpack`, 那么模块的目录就是 `/usr/local/lib/node_modules/webpack`, 然后通过软链接的方式，将 `bin` 字段配置的可执行文件链接到 `/usr/local/bin` 目录下。

8. 异步 `I/O`

    `node` 既可以作为服务器去处理客户端带来的大量并发请求，也能作为客户端向网络中的各个应用发起并发请求。

    `Web` 的含义是网，而 `node` 的表现正如它的名字一样，是网络中一个灵活的节点。

    异步 `I/O` 在 `node` 里面是如此重要，与 `node` 面向网络的设计有很大的关系。

    `I/O` 是昂贵的，而分布式 `I/O` 更加昂贵。这就是异步 `I/0` 在 `node` 中盛行的原因, 因为异步获取资源，比同步获取资源消耗更少。而且随着应用规模的扩大，这用优势会越来越明显。

    `node` 相比其他语言，通过异步 `I/O`，能更快的响应资源，让前端的体验变好？？

    `node` 的优势:
    - 利用单线程，远离多线程死锁、状态同步问题；
    - 利用异步 `I/O`, 让单线程远离阻塞，以更好的使用 `CPU`；
    - 利用 `child_process`， 更高效的利用 `CPU` 和 `I/O`;

    `node` 的异步 `I/O` 是基于 `event loop` 实现的。

    `event loop` 是一个典型的生产者/消费者模型。异步 `I/O`、网络请求等是事件的生产者，源源不断的为 `node` 提供不同类型的事件，这些事件会传递到观察者那里， `event loop` 则从观察者那里取出事件来处理。

    `node` 实现高性能服务器：异步 `I/O` + 事件驱动(轮询);

9. 异步编程

    函数式编程:
    - 函数是一等公民，可以调用、可以作为函数入参、也可以作为函数返回值。
    - 异步编程与函数式编程的关系？？: 或者可以理解为，正式因为函数可以作为参数，也可以作为返回值，所以才能异步编程？？
    - 高阶函数: 可以把函数作为入参，也可以把函数作为返回值，如 `forEach`、`map`、`reduce` 等方法。
    - 偏函数: 通过指定部分参数，产生一个新的定制函数的用法。

    `node` 的灵魂所在: 基于事件驱动的非阻塞 `I/O` 模型。
    
    非阻塞 `I/O`，可以使 `CPU` 和 `I/O` 不需要相互依赖等待，让资源得到更好的利用。对于网络应用而言，并行带来的想象空间更大，延展而开就是分布式和云。并行使得各个单点之间能够更加有效的组织起来，这也是 `Node` 在云计算产商中广受青睐的原因。(现在是这样吗？？)

    只要合理利用 `node` 的异步模型与 `V8` 的高性能，就可以充分发挥 `CPU` 和 `I/O` 资源的优势。

    异步编程的难点:
    - 异常处理；
    - 函数嵌套过深；
    - 无法阻塞代码；
    - 无法多线程编码(这个可以使用 `child_process`， `cluster` 来解决这个问题)；
    - 异步转同步；

    异步编程的解决方案:
    - 事件发布/订阅模式；
    - promise
    - async / await, generator ??


10. 内存控制









问题收集:
- 函数式编程 ？？
- 异步编程和函数式编程有什么关系？？
- node 目前在分布式、云中的应用场景怎么样？？


















