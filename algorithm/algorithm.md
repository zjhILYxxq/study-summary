#### 常用的算法解题思路

常见的问题类型、解题思路、典型问题:
- **求最值**问题：**动态规划**，解题思路为**子问题的最优解得到原问题的最值**，典型题有**斐波那契数列**、**跳楼梯**、**股票**；
- **列出所有情况**的问题：**回溯算法**，解题思路为**将问题转化为多叉树的深度优先遍历**，典型题有**全排列**、**皇后问题**
- **最短路径**的问题: **BFS - 广度优先遍历**，典型题有**二叉树的最小高度**、**走迷宫**、**密码锁问题**等；
- **链表问题**: 常用的解题方法有**双指针**、**快慢指针**、**正常遍历**、**配合其他数据结构使用如堆**，典型题有**合并两个链表**、**合并多个链表(配合堆使用)**、**寻找倒数第 k 个节点(双指针)**、**找到链表的中间节点(快慢指针)**、**判断链表有环(快慢指针)**、**判断链表相交(双链表)**；
- **数组、字符串问题**: 常用的解题方法有**左右指针**、**滑动窗口**等，典型题目有
- **二分查找问题**:
- **字符串问题**:
- **数组问题**: 
- **岛屿问题**:
- 



#### 动态规划

**动态规划**问题的一般形式就是：**求最值**。

**动态规划**的核心思想：**穷举**。

动态规划问题的特点:
- 存在**重叠子问题** - 重叠子问题会导致不必要的计算；
- 具备**最优子结构** - 通过子问题的最值找到原问题的最值；
- 正确的**状态转移方程** - 只有列出正确的状态转移方法，才能正确的穷举； 


写出**状态转移方程**的思路:
- 明确 base case  - 找到初始情况；
- 明确状态 - 找到变化的值；
- 明确选择 - 选出最值的过程；
- 明确 dp 函数/数组的定义；

**动态规划问题**的解法：
- **自顶而下** - 递归，即确定 dp 函数，需要使用备忘录消除重叠子问题；
- **自底而上** - dp 数组；

常见的动态规划问题的解题过程:
- 斐波那契数列
- 跳楼梯
- 硬币
- 股票


#### 回溯算法 - DFS(深度优先遍历算法)

**回溯算法**问题的一般形式就是：**列出某个问题的所有情况**。

**回溯算法**的核心思想: **穷举**。

**回溯算法**的解题思路: 将问题转化为**多叉树的深度遍历问题**。

**回溯算法**的具体解题思路:
- 先将问题转化为一颗**多叉树**；
- 采用深度优先遍历方式(先遍历子节点，再遍历兄弟节点)，收集所有遍历到叶子节点的路径；
  
**回溯算法**的关键点是**递归 + 回溯**，解题模板：

```
let result = [];

let tract = [];

function backTrack(list, track) {

    if (满足条件) {
        result.add(track.slice(0))
    }

    for(item of list) {
        if (判断 item 是否可以添加到 track 中) {
            track.push(item);  // 做选择(处理当前节点)
            backTrack(list, track);  // 比那里子节点
            track.pop(item);  // 撤销选择(准备遍历兄弟节点)
        }
    }
}
```

回溯算法需要的时间复杂度很大，解题规模一般比较小。

#### BFS 算法

**BFS**，**广度优先遍历**, 一般会借助**队列 - queue** 来实现。

**BSF** 和 **DSF** 算法相比，算法的空间复杂度要高一些。

**BFS** 算法的关键：能把实际问题理解为 **BFS**。

**DFS**、**BFS** 算法的的一般解题思路：将**实际问题转化为多叉树的遍历**，**求全解用 DFS**， **求最短用 BFS**


#### 链表问题

**链表问题**的常用解法: **双指针**、**快慢指针**。

- **合并两个有序链表**: 利用临时缓存合并(空间复杂度较高)、以某一链表为主合并(合并逻辑会稍微复杂一点)。
- **合并多个有序链表**: 利用临时缓存 + 最小堆(空间复杂度较高)。
- **寻找倒数第 k 个节点**: 双指针，第一个指针先走 k 步，然后第二个指针指向链表的头部，之后两个指针一起向后遍历，第一个指针到到链表尾部时，第二个指针也就指向了链表的第 k 个节点。
- **寻找链表的中间节点**: 快慢指针，一个指针一次走两步，另一个指针一次走一步，当第一个指针到达链表尾部时，第二个指针也就指向了链表的中间节点。
- **判断链表有环**: 快慢指针，一个指针一次走两步，另一个指针一次一步，快指针能追上慢指针，说明有环，否则没有。当快指针指向 null 或者快指针的 next 指向 null，停止追赶。
- **判断链表环的起点**: 快指针追上慢指针以后，慢指针指向 head，快指针继续前进，两者再次相遇的节点就是环的起点。
- **判断链表相交**: 双指针,第一个指针先遍历 A，再遍历 B; 第二个指针先遍历 再遍历 A； 当两个指针指向同一个节点时，说明链表相交。

#### 数组、字符串问题

数组、字符串问题的常用解法: **左右指针**、**滑动窗口**

- **数组、字符串反转**: 使用**左右指针**；
- **字符串寻找满足提议的子串**: 使用**左右指针**、**滑动窗口**，整个过程如下:
  - 移动右指针，扩大窗口，直到满足要求为止；
  - 移动左指针，缩小窗口，满足要求就更新结果；不满足要求，停止移动；
  - 重复第一步，移动右指针，直到右指针到底为止；





#### 滑动窗口





#### 排序

特别关注一下堆 ！！

