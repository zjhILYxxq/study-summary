#### 常用的算法解题思路

常见的问题类型、解题思路、典型问题:
- **求最值**问题：**动态规划**，解题思路为**子问题的最优解得到原问题的最值**，典型题有**斐波那契数列**、**跳楼梯**、**股票**；
- **列出所有情况**的问题：**回溯算法**，解题思路为**将问题转化为多叉树的深度优先遍历**，典型题有
- **最短路径**的问题: **BFS - 广度优先遍历**，典型题有**二叉树的最小高度**、**走迷宫** 等；
- **链表问题**:



#### 动态规划

**动态规划**问题的一般形式就是：**求最值**。

**动态规划**的核心思想：**穷举**。

动态规划问题的特点:
- 存在**重叠子问题** - 重叠子问题会导致不必要的计算；
- 具备**最优子结构** - 通过子问题的最值找到原问题的最值；
- 正确的**状态转移方程** - 只有列出正确的状态转移方法，才能正确的穷举； 


写出**状态转移方程**的思路:
- 明确 base case  - 找到初始情况；
- 明确状态 - 找到变化的值；
- 明确选择 - 选出最值的过程；
- 明确 dp 函数/数组的定义；

**动态规划问题**的解法：
- **自顶而下** - 递归，即确定 dp 函数，需要使用备忘录消除重叠子问题；
- **自底而上** - dp 数组；


#### 回溯算法 - DFS(深度优先遍历算法)

**回溯算法**问题的一般形式就是：**列出某个问题的所有情况**。

**回溯算法**的核心思想: **穷举**。

**回溯算法**的解题思路: 将问题转化为**多叉树的深度遍历问题**。

**回溯算法**的具体解题思路:
- 先将问题转化为一颗**多叉树**；
- 采用深度优先遍历方式(先遍历子节点，再遍历兄弟节点)，收集所有遍历到叶子节点的路径；
  
**回溯算法**的关键点是**递归 + 回溯**，解题模板：

```
let result = [];

let tract = [];

function backTrack(list, track) {

    if (满足条件) {
        result.add(track.slice(0))
    }

    for(item of list) {
        if (判断 item 是否可以添加到 track 中) {
            track.push(item);  // 做选择(处理当前节点)
            backTrack(list, track);  // 比那里子节点
            track.pop(item);  // 撤销选择(准备遍历兄弟节点)
        }
    }
}
```

回溯算法需要的时间复杂度很大，解题规模一般比较小。

#### BFS 算法

BFS，广度优先遍历。



#### 滑动窗口


#### 双指针



#### 排序

特别关注一下堆 ！！


#### 