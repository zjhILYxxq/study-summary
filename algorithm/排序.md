#### 排序定义

按排序完成位置：
- **内部排序** (数据量较小，可以在内存中完成);
- **外部排序** (数据量较大，不能在内存中完成，必须在磁盘或者磁带上完成);

内部排序：
- 插入排序： 直接插入排序，拆半插入排序；
- 交互排序： 冒泡排序、快速排序；
- 选择排序： 简单选择排序、树排序、快速排序；
- 归并排序
- 分配排序


#### 插入排序

- **直接插入排序**

    思路：**确定第 n 个元素的位置时，前面的 n - 1 个元素已排好序。倒序和前面的 n - 1 个元素依次比较大小，找到位置，向后移动比 n 大的元素**。

    ```
    function insertionSort(nums) {
        if (!nums || !nums.length) return [];
        for(let i = 0; i < nums.length; i++) {
            let temp = nums[i];
            let j;
            for(j = i; j > 0 && nums[j - 1] > temp; j--) {
                nums[j] = nums[j - 1]
            }
            nums[j] = temp
        }
        return nums;
    }
    ```
    时间复杂度： O(n^2); 空间复杂度: O(1)

    适用于初始记录基本有序的情况。当初始记录无序， n 较大时，算法复杂度较大。

- **拆半插入排序**

    思路：**采用拆半的方法，找到第 n 个元素的位置，向后移动比 n 大的元素**。

    ```
    function findIndex() {

    }

    function insertionSort(nums) {
        if (!nums || !nums.length) return [];
        for(let i = 0; i < nums.length; i++) {

        }
    }
    ```

#### 交换排序

- **冒泡排序**

    冒泡排序的思想：把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换他们的位置；当一个元素小于或者等于右侧相邻的元素时，不交换他们的位置。**每次排序时，总能确定一个元素的最终位置**。

    ```
    function bubbleSort(nums) {
        if (!nums || !nums.length) return [];
        for(let i = 0; i < nums.length - 1; i++) {
            let temp;
            for(let j = 0; j < nums.length - i - 1; j++) {
                // 如果是 if(nums[j] < nums[j + 1]), 那么就是从大到小排序
                if (nums[j] < nums[j + 1]) {
                    temp = nums[j + 1];
                    nums[j + 1] = nums[j];
                    nums[j] = temp;
                }
            }
        }
        return nums;
    }
    ```
    时间复杂度：O(n^2), 空间复杂度: O(1)。

    冒泡排序的优化：**如果判断数列已经有序，就不必再排序了**

    ```
    function bubbleSort(nums) {
        if (!nums || !nums.length) return [];
        for(let i = 0; i < nums.length - 1; i++) {
            let temp, isFinish = true;
            for(let j = 0; j < nums.length - i - 1; j++) {
                if (nums[j] > nums[j + 1]) {
                    temp = nums[j + 1];
                    nums[j + 1] = nums[j];
                    nums[j] = temp;
                    isFinish = false;
                }
            }
            if (isFinish) {
                break;
            }
        }
        return nums;
    }
    ```

- **鸡尾酒排序**



- **快速排序**


