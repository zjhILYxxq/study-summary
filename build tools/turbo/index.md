1. `Turbo` 是用于前端开发的下一代工具链，用 `Rust` 编写。它主要有 3 个部分构成:
- `Turbopack`，增量打包器，`Webpack` 的继承者；
- `Turborepo`，增量构建系统；
- `Turbo` 引擎，一个增量计算和记忆引擎；

2. `Turbopack`

    `Turbopack` 是针对 `javascript` 和 `typescript` 优化的增量打包器，由 `Vercel` 的 `Webpack` 和 `Next.js` 的创作者用 `Rust` 编写。

    `Turbopack` 性能的秘诀: 高度优化的机器代码和增量计算引擎，可以缓存到单个函数的级别(专注于使用缓存来避免重复执行相同的工作)。

3. 为什么是 `Turbopack`

    `Vite`, 不会在开发模式下捆绑应用程序源代码。 相反，它们依赖于浏览器的原生 `ES Modules` 系统。 这种方法会导致令人难以置信的响应更新，因为它们只需要转换单个文件。但是，`Vite` 可能会遇到由许多模块组成的大型应用程序的扩展问题。 浏览器中的大量级联网络请求会导致启动时间相对较慢。 对于浏览器来说，如果它可以在尽可能少的网络请求中接收到它需要的代码——即使是在本地服务器上，它会更快。

    这就是为什么我们决定像 `Webpack` 一样，希望 `Turbopack` 将代码捆绑在开发服务器中。 `Turbopack` 可以更快地完成它，尤其是对于大型应用程序，因为它是用 `Rust` 编写的，并且跳过了仅在生产环境中需要的优化工作。

    有两种方法可以加快进程：减少工作量或并行工作。 我们知道，如果我们想让最快的打包机成为可能，我们需要用力拉动两个杠杆。

    我们决定为分布式和增量行为创建一个可重用的 `Turbo` 构建引擎。 `Turbo` 引擎就像函数调用的调度程序一样工作，允许在所有可用内核上并行调用函数。

    `Turbo` 引擎还缓存它调度的所有函数的结果，这意味着它永远不需要两次执行相同的工作。 简而言之，它以最大速度完成最少的工作。

    其他工具对“做更少的工作”采取不同的态度。 Vite 通过在开发模式下使用 Native ESM 将工作量降至最低。 出于上述原因，我们决定不采用这种方法。

    在底层，`Vite` 将 `esbuild` 用于许多任务。 `esbuild` 是一个捆绑器 - 一个非常快的。 它不会强迫您使用本机 ESM。 但出于几个原因，我们决定不采用 esbuild。

    `esbuild` 的代码针对一项任务进行了超优化 - 快速捆绑。 它没有 `HMR`，我们不想从我们的开发服务器中丢失它。

    `esbuild` 是一个非常快速的打包工具，但它并没有做太多的缓存。 这意味着你最终会一次又一次地做同样的工作，即使这项工作是以本机的速度进行的。

    Evan Wallace 将 `esbuild` 称为下一代打包工具的概念验证。 我们认为他是对的。 我们认为具有增量计算的 `Rust` 驱动的 `bundler` 在更大的规模上可以比 `esbuild` 更好地执行。

    Next.js 的早期版本试图在开发模式下捆绑整个 Web 应用程序。我们很快意识到这种“急切”的方法并不是最优的。 Next.js 的现代版本仅捆绑开发服务器请求的页面。例如，如果您访问 localhost:3000，它只会捆绑 pages/index.jsx 和它导入的模块。

    这种更“懒惰”的方法（仅在绝对必要时捆绑资产）是快速开发服务器的关键。本机 ESM 无需太多魔法即可处理此问题 - 您请求一个模块，该模块又请求其他模块。但是，出于上述原因，我们想构建一个捆绑器。

    `esbuild` 没有“惰性”捆绑的概念——它是全有或全无，除非您专门针对某些入口点。

    `Turbopack` 的开发模式会根据收到的请求构建应用程序导入和导出的最小图，并且只捆绑必要的最少代码。在核心概念文档中了解更多信息。

    这种策略使 `Turbopack` 在第一次启动开发服务器时变得非常快。我们只计算渲染页面所需的代码，然后将其以单个块的形式发送到浏览器。在大规模情况下，这最终比原生 ESM 快得多。

    构建 `Turbopack` 的原因:
    - 构建一个 `bundle`。 在处理大型应用程序时，捆绑程序的性能优于本机 ESM。
    - 使用增量计算。 `Turbo` 引擎将这一点带入 `Turbopack` 架构的核心 - 最大限度地提高速度并最大限度地减少完成的工作。
    - 优化我们的开发服务器的启动时间。 为此，我们构建了一个惰性资产图来仅计算请求的资产。


4. `Turbo` 引擎

    `Turbopack` 之所以这么快，是因为它建立在一个可重用的 `Rust` 库之上，该 Rust 支持增量计算，被称之为 `Turbo` 引擎。

    `Turbo` 引擎的工作模式 - 函数级别的缓存？？

    在使用 `Turbo`引擎的程序中，可以将某些函数标记为 `to be remembered`。当这些函数被调用时，`Turbo` 引擎会记住它们被调用的情况，以及它们返回的内容，然后它将其保存在内存缓存中。

    这个缓存策略，和 `webpack` 的缓存策略有什么区别？？

5. 按需编译

    主要是为了更快的启动 `dev server`，做更少的工作。

    `next11` 之前，需要编译打包整个应用的代码。

    `next11` 之后，可以根据页面请求，只对需要的代码进行编译打包，即 `page-level compilation`。

    使用 `Turbo` 之后，可以只编译请求的代码，即 `request-level compilation` ？？ 不分析依赖关系吗？












