#### 微前端相关

- [x] **微前端的概念、优点、挑战、常用技术方案**

    微前端可以用来解决日益庞大的项目带来的开发、构建、部署、维护、技术栈升级的问题，并且可以技术栈无关的对接其他应用。

    概念: 将一个巨石应用，按照一定的规则拆分为不同的子应用，然后将多个子应用聚合为一个应用。

    优点: 独立、低耦合的仓库、子应用可独立开发/部署、迁移老的系统、子应用技术栈升级、团队技术成长；

    挑战: 增加项目的复杂度(主应用、子应用)、子应用之间切换、应用之间相互隔离互不影响、子应用之间通信/交互、多个子应用并存、用户状态；

    常用的技术方案: 路由转发、iframe、ssr、single-spa、qiankun、webpack5 - module federation、web component；

    路由转发
    - 优点：实现简单；不需要现有应用做改造；技术栈无关；
    - 缺点: 子应用切换需要刷新浏览器，用户可感知，体验不好；多个子应用无法共存；子应用之间通信困难；子应用之间无法交互；局限性比较大；

    iframe
    - 优点： 实现简单； 不需要对现有应用做改造；技术栈无关；css、js 天然隔离，互不影响；多个子应用可以共存；不需要对现有子应用做改造；
    - 缺点： 每次切换应用，需要重新加载页面，用户体验不好； UI 不同步，dom 结构不共享； 子应用之间通信、交互非常复杂；对 SEO 不友好；

    ssr
    - 优点：不需要对应有应用改造；子应用之间技术栈无关；多个子应用可以并存；对 seo 友好；不需要对现有子应用做改造；
    - 缺点: 用户体验不好，子应用切换的时候需要刷新页面，重新走 SSR，用户可感知；实现复杂，需要对 node 有了解；子应用之间会相互影响；子应用之间通信、交互比较复杂；

    single-spa
    - 优点: 能实现单页应用的用户体验；子应用之间技术栈无关；多个子应用可以共存；生态丰富；
    - 缺点: 需要对现有子应用做改造，有一定的成本；使用复杂，关于子应用的加载、通信、隔离逻辑，都需要开发者自己实现；子应用之间相同资源重复加载；首屏加载较慢，需要先启动基座应用，再启动子应用；
  
    qiankun
    - 优点: 能实现单页应用的用户体验；子应用之间技术栈无关；多个子应用可以共存；生态丰富；使用简单，框架自身实现了子应用隔离、通信、加载的逻辑；
    - 缺点: 需要对子应用做改造；有一定的学习成本；相同资源重复加载；首屏加载缓慢，需要先启动基座应用，再启动子应用；子应用之间交互比较麻烦；

    module federation
    - 优点: 能实现单页应用的用户体验；多个子应用可以共存；相同资源不需要重复加载；子应用之间交互非常方便；
    - 缺点：项目打包依赖 webpack5； 有额外的学习成本；单独使用存在子应用互相影响的情况；

    web component:
    - 优点： css、js 天然隔离；技术栈无关；多个子应用可以共存；不需要对子应用改造；
    - 缺点： 浏览器兼容性问题、开发成本较高；

    最佳实践: ssr + qiankun + module federation;

- [x] **single-spa**

    single-spa 中，应用分为两类：主应用和子应用。子应用是需要聚合的应用，主应用用来聚合子应用。

    主应用会维护一个路由注册表，根据当前路由信息，获取对应的子应用的 js 脚本，然后通过 csr 的方式渲染页面；如果是已经访问过的子应用，则从缓存中获取子应用的 mount 方法，重新激活子应用。

    使用 single-spa 时， 需要对子应用做三个方面的改造：
    - 提供 mount、unmount、update 生命周期方法。其中，mount 在子应用时激活调用，调用时会通过 csr 的方式渲染页面；unmount 在子应用冻结时调用；
    - 打包构建的改造，将生命周期方法暴露给主应用(library、libraryTarget)，通过 publicPath，补全子应用资源加载路径；
    - 子应用路由改造，需要添加子应用前缀；

    single-spa 提供了两种模式： application 模式和 parcel 模式：
    - application 模式：子应用的切换由修改路由触发，整个切换过程由框架控制；应用场景：多个子应用聚合；
    - parcel 模式： 子应用/组件的挂载和卸载，由开发人员手动触发；应用场景：跨框架使用组件；

    不管是 appliation 模式还是 parcel 模式，生命周期方法执行时，都要放回一个 promise 对象。 promise 状态变为 resolved，才真正 mount/unmount。

    application 模式下子应用切换的原理:
    - pushState/replace/popstate,  hash/hashchange;
    - 执行 pushState/replaceState 触发 popstate 的方式: 重写原生的 pushState / repalceState 方法，执行时手动创建一个 popstate 类型的事件对象，然后通过 window.dispatchEvent 方法手动触发 popstate 事件；


    application 模式下的工作过程：
    - 主应用通过 registerApplication 方法注册子应用；
    - 主应用挂载完成以后，执行 start 方法，根据当前路由去选择子应用加载；
    - 获取到子应用的生命周期方法以后，执行子应用的生命周期方法，以 csr 的方式渲染子应用；
  
    子应用通信: 通过主应用传递的 customProps，以主应用为中介，进行通信；

    single-spa 的不足:
    - 复杂的子应用加载方式(子应用打包构建时生成一个 manifest 存储起来，主应用加载子应用时再根据 manifest 获取子应用的入口文件、css 内容)；
    - 子应用隔离、预加载、切换遗留的副作用、状态恢复，都需要开发人员自己去处理；
    
  
- [x] **qiankun**

    qiankun 是在 single-spa 的基础上做了二次开发，提供了通用的子应用加载、通信、预加载方案，并通过技术手段实现了 js / css 的隔离、副作用的清理、状态恢复。

    qiankun 和 single-spa 的用法基本相同，也分 application 和 parcel 模式，子应用的改造也完全一样。

    子应用加载 - html entry:
    - 获取子应用的入口 html 文件；
    - 解析 html 文件，拿到 js 脚本、css 脚本；
    - 获取外部样式表，将外部样式表和内部样式表都添加到新生成的 html 模板中，将新生成的 html 模板添加到当前 html 页面中；
    - 手动触发 js 脚本的执行，拿到子应用生命周期方法，以 csr 的方式渲染子应用；
  
    js 隔离 - sandbox：
    - 为每一个对象创建唯一的类 window 对象；
    - 将 js 脚本使用一个立即执行函数包裹， 将类 window 对象作为 js 脚本执行的全局变量

        ```
        (function(window) { ... })(fakeWindow)
        ```
    - 通过 eval 方法手动触发 js 脚本；
  
    qiankun 的 sandbox：
    - proxySandbox - 基于 proxy 实现： 先创建一个类 window 对象，然后构建类 window 对象的 proxy 拦截对 fakeWindow 对象的读写(直接写到 fakeWindow；读时先读 fakeWindow，再读原生 window)；
    - snapshotSandbox - 快照沙盒: 子应用激活时，先把当前的 window 对象的可枚举属性拷贝一份，window 对象作为子应用的全局对象；子应用冻结时，对比 window 和 fakeWindow， 缓存发生变化的属性；子应用再次激活时，会先根据上次缓存的变化的属性恢复之前的状态；

    css 隔离：
    - 严格隔离 - 基于 web component 的 shadow dom 实现；

        ```
        const shadow = element.createShadowRoot();

        const shadow = element.attachShadow({ mode: true });
        ```
    - scoped 样式隔离 - 给样式添加属性选择器；
  
    动态添加的 script、style，也会做隔离，原因是 qinakun 对 appendChild 方法做了拦截，重写了 appendChild 方法，然后对 js、css 做隔离。

    副作用的清理： 
    - sandbox 隔离，没有副作用；
    - dom 节点都是添加到子应用对应的 html 片段中，子应用卸载， html 片段会移除；
    - 重写 setTimeout、setInterval、appendChild、addEventListener 等方法，这些方法执行时会返回一个 destory 方法；子应用卸载时会触发 distory 方法。

    子应用的状态恢复：
    - sandbox 机制会给子应用恢复状态；
    - 动态添加的样式会一直缓存，每次子应用激活时都重新添加；

    子应用通信： 基于发布订阅模式实现。主应用构建一个 state，并维护一个 deps；子应用可以通过 onGlobalStateChange 订阅 state 的变化，并通过 setGlobalState 修改 state。

    子应用可以预加载。

    使用 qinakun 的 sannbox 隔离 js、css， 一般仅限于隔离子应用且子应用不能同时存在。

    sandbox 做 css 隔离的原理是: 子应用挂载时， css 样式会添加到子应用对应的 html 片段内；子应用卸载时， css 样式会随着 html 片段的移除而移除，不会影响下一个子应用。

    如果父子应用、多个子应用之间存在样式互相影响时，有三种解决方案:
    - 严格样式隔离， 基于 css shadow 实现；
    - scoped 样式隔离， 基于属性选择器实现；
    - 给子应用的样式添加自定义前缀, 如 antd 添加样式前缀；


- [x] **qiankun 存在的问题**


    qiankun 的问题： 子应用首次加载时 preload、prefetch 会失效。
    
    解决方式:
    - 主应用通过 ssr 对子应用的入口资源进行预加载；
    - 修改 qiankun 的源码，解析 html 收集 scripts 时，要将预加载的 script 脚本收集起来，先通过 fetch 方法去预加载。等到真正去 fetch 的时候，可以从缓存中直接拿。
  
- [x] **使用 Web Component 实现微前端**

    依赖的技术:
    - 自定义元素 - custom element；
    - shadow dom；
    - template；

    过程:
    - 定义一个自定义的元素类，继承自 HTMLElement；
    - 使用 window.customElements.define('xx', xxx), 将自定义元素和元素类关联；
    - 使用自定义元素；
    - 执行自定义元素的构造函数，通过 shadow 加载子应用，隔离 js、css；


- [x] **saas 关于微前端的最佳实践** 

    原来的项目中实现微前端的方式: SSR, 每次切换子应用时通过 a 标签 href 的方式切换应用，每次都需要重新加载页面，体验很差。

    目前 SaaS 中微前端的实现方案: ssr + qiankun + module federation, 整个应用看起来就想一个 spa 应用。

    其中，主应用采用 ssr 的方式渲染；子应用采用 csr + qiankun 的方式渲染；子应用之间交互采用 module federation。

    未来需要改进的地方：采用当前模式，首屏渲染较长； seo 不友好。 未来会考虑子应用首次加载的时候也采用 ssr 的方式。

    本地调试 lego 的原理：
    - 先起本地应用；
    - 再起一个 express 应用，代理到指定环境，html 使用指定环境的；js、css 使用通过 proxy 使用本地的代码；

    将子应用也改为 ssr 的方式:

    - 将子应用做改造

        根据需要给每个组件添加数据获取方法。

    - 子应用 build 时采用两种方式:
      - 一种方式为单入口文件打包，打包出来的 bundles 用作 CSR；
      - 另一种方式为多入口文件打包，将路由中的每一个页面的 index 作为入口文件打包，为每一个页面生成一个 bundles；

      将打包好的文件上传 cdn；

    - 服务端渲染时先配置好各个子应用在 cdn 上静态资源的位置。

        根据客户端访问路由，找到子应用具体页面的打包文件，执行，执行 js 文件，得到组件。

        根据组件的数据获取方法，获取数据，然后作为 props 传入 组件方法，返回组件的 react element。

        然后使用 react.renderToString 将组件的 react element 转化为字符串；

        将渲染完毕的字符串，通过 application/json 类型的 script 标签添加到 html 页面中

    - 主应用渲染完毕以后

        在 useEffect 回调方法中，获取预渲染的组件字符串，添加到子应用的挂载节点下，然后再通过 qiankun 加载子应用。

    子应用的改造:
    - 子应用的 index 中要支持 render 和 hydrate 两种模式；
    - 对每一个页面组件都需要改造；
    - 对打包构建需要改造；


    SaaS 子应用 csr to ssr 的改造过程(涉及子应用和主应用的改造)
    - 子应用的改造过程(需要考虑的点-每个页面都需要单独单独打包成一个独立的 chunk(和懒加载分离的 chunk 不一样哦)、自动加载、版本回滚)：
      - 子应用 app.js 渲染时提供两种模式: render 和 hydrate;
      - 需要一个多入口的打包脚本， entry 为页面的 name， output 的 library 也为页面的 name， libraryTarget 为 umd；
      - 每个页面需要做简单改造：无数据时的页面呈现；有数据时的页面呈现；如果使用了 contextType， 还需要对页面组件包装一下，传入一个空的 context；
      - 打包以后的文件， 根据 asset-manifest，拿到页面名称和对应的静态资源连接的映射关系，deploy 的时候写入数据库(这样写入数据库的就两份：单入口文件打包和多入口文件打包；)；
      - 将打包好的文件上传 CDN；
  
    - 主应用的改造过程；
      - 读取数据库，拿到当前版本的静态文件；
      - 根据路由，找到当前路由匹配的子应用以及子应用的具体页面；
      - 拿到子应用的入口文件、css 样式文件，以及子应用具体页面的对应的 js 文件；
      - 通过 fetch 拿到子应用页面的 js 脚本，通过 eval 方式执行，拿到子应用页面对应的组件；
      - 执行组件方法，拿到组件对应的 react element；
      - 执行 react.renderToString 方法，将 react element 转化为 html string;
      - 将 html string 通过一个 application/json 类型的 script 标签添加到返回给客户端的 html 页面中；
      - 主应用 hydrate 完成以后，将子应用页面的 html string 添加到子应用的容器节点下面；
      - 子应用渲染时，判断是否走 ssr。如果走 ssr，调用 hydrate 方法；如果不走 render 方法，调用 render 方法；

    SaaS 首屏渲染优化:
    - 子应用需要需要的通用数据，放到 ssr 中先执行，然后注入到 window 对象中；
    - 主应用和子应用都走 ssr；
    - 解析要要加载的子应用时，preload 子应用需要的入口文件及样式文件(这个要试一下， prefetch 和 preload 有什么区别);


    SaaS 性能优化:
    - FCP: First Contentful Paint, 从页面开始加载到页面内容呈现在屏幕上的时间，优化策略： 主应用采用 SSR
    - SI: Speed Index， 页面内容的可填充速度，主要是要考虑渲染过程有没有被阻塞；
    - LCP: Largest Contentful Paint, 渲染出最大文本、图片的时间, 优化策略: 子应用采用 SSR；
    - TTI: 可交互时间
    - TBT: 总的阻塞时间
    - CLS: Cumulative Layout Shift， 累计位移偏移，优化策略: 给元素固定 width、height，主要是图片；
        
    
    在 js 中测量上述指标 - 使用原生的 performance API：

    ```
    new PerformanceObserver((entryList) => {
        for (const entry of entryList.getEntries()) {
            console.log('LCP candidate:', entry.startTime, entry);
        }
    }).observe({type: 'largest-contentful-paint', buffered: true});
    ```

    **如何计算 LCP**: 浏览器会在绘制第一帧后立即分发一个 **largest-contentful-paint** 类型的 **PerformanceEntry**，用于识别**最大内容元素**。但是，在渲染后续帧之后，浏览器会在最大内容元素发生变化时分发另一个 **PerformanceEntry**。

- [x] **SaaS 为什么要采用 SSR 架构**

    采用 SSR 结构的三个原因：
    - 首屏性能优化，主应用可以直出 html 页面；借助 SSR，子应用也可以直出 html 页面，还可以预加载；
    - 实现一个简单的 BFF 层，可以实现权限控制、版本控制、接入到第三方应用时的鉴权控制、接口聚合、接口缓存、承接复杂业务等；
    - 尝试不同的技术实现；


- [x] **子项目一键接入 sentry**

    接入过程：
    - 收集项目名称、dsn、静态资源位置、路径前缀；
    - 创建 .sentryclirc 文件；
    - 创建一个 hoc；
    - 更新 package.json 的 script 脚本，添加上传 source-map 的命令，并整合到 build 命令下；
    - 安装依赖；
  
- [x] **aicc 业务**

    **AI 语音三大算法**：
    - **ASR 语音识别**, 将人的语音转化为文字；
    - **NLP 语义理解**，自然语言处理技术；
    - **TTS 语音合成**, 文本转语音技术；
    
    **aicc** 通用业务流程:
    - 创建一个话术，配置决策树，训练 (TTS - 知识库、热词、关键词? 精准识别关键词？话术要训练？)；
    - 创建外呼任务: 话术配置、线路配置；
    - 发起外呼任务；
    - 语音对话交互(ASR、NLP、TTS、坐席监听、通话监听、AI 转人工)；
    - 数据分析统计

    rtp: 实时传送协议

    FreeSwitch、Sip、引擎端、客户端之间的关系

    FreeSwitch: 跨平台的开源电话交换平台

    Sip: 协议；

    WebRTC: 网页实时通信技术；

    
    aicc 话术处理逻辑要整理一下！！


- [x] **SaaS 关于微前端的实现**

    微前端架构，比较核心的部分是子应用的切换机制、子应用的相互隔离。

    之前的版本，微前端子应用的切换基于 ssr 的动态路由机制实现的。每次子应用切换的时候，都需要浏览器重新加载，都需要经历 node 服务端直出主应用 html 页面，然后主应用渲染，子应用去手动拉取 js、css 文件，然后渲染子应用。

    这种架构下存在的一些问题:
    - 子应用切换时的体验不是很好。每次切换子应用，都需要 node 服务端直出 html 页面， 需要一定的服务端响应时间。而且 node 服务里面有一些前置接口需要调用，每次切换子应用，重复接口调用。这里子应用的静态资源虽然会有强缓存，但是体验上明显不如 spa。
    - 不能满足新的业务需求。原来的业务，是一级菜单在顶部，按照项目来划分，二级菜单是子应用里面的路由配置，采用原来的架构，用户使用应用时，割裂感不是很强。新业务线调整以后，功能划分不再以项目划分，而是根据业务线来划分的，这就导致了页面上的某一个一级菜单下的二级菜单来自不同的子应用。这个时候，原来的架构带来的体验就不好了，割裂感特别严重，这时就需要我们的 SaaS 应用也能达到 SPA 的效果。
    - 重构子项目时，只能通过 iframe 的方式接入；


    基于此，采用 qiankun 对原来的微前端实现方案进行调整，这样带来的好处：
    - 访问应用时，服务端只需要直出一次 html 页面，前置接口也只需要调用一次；
    - 已经访问过的子应用可以缓存，未访问过的子应用可以预加载；
    - 子应用切换如同 spa 一样，体验升级；
    - 从原来的架构改成 qiankun，改造成本也不大；
    - 方便升级老项目的技术栈，重构业务；
  
    有没有考虑过 iframe ？ 有。

    iframe 实现微前端方案非常简单。其实不管是业务改版之前，还是业务改版之后，子应用的切换都可以使用 iframe 来做。但是，使用 iframe 的话会存在一个问题。我们是把菜单放在主应用的，然后子应用通过 iframe 展示。

    使用 iframe 这种方案的话，有一些不足:
    - 子应用间切换，需要更新 iframe 的 src，重新加载；
    - 子应用内部菜单切换，需要通信，通知 iframe 去做更新；
    - 用户体验不好，通信复杂，改造成本比对接 qiankun 的成本还大；

- [x] **子应用使用 module federation， remote 应用的代码变了怎么办**

    remote 应用的 expose 的代码上传到 cdn，对应的地址要存到数据库中。

    host 应用本地启动或者生产环境 build 时，要先从数据库中读 remote 应用 expose 代码的地址，然后更新 webpack 中的 remote 配置项。



- [x] **前端可以做的事情**

    前端回滚 - 帮助运维，可视化回滚；

    前端 icon 库，自动添加 icon npm 包，自动 publish npm 包；

    前端 pmp - 对接 jira 内部接口、企业微信、sentry，推送 jira 通知、企业微信通知、sentry 异常；

    前端还可以开发类似低代码的编辑器，帮助运营快速制定活动页；

    开发一个内部应用，内部聚合开发人员日常所使用的应用，提高人效；

    内部基建、组件库等；

- [x] **偶发性问题排查的技巧**

    1. 模仿用户行为，根据用户环境，重现问题；
    2. 查看相关日志；
    3. 分析用户数据、查看代码逻辑；

    有时候，我们会出现无法复现问题、日志不全、代码逻辑无法分析、用户环境也是偶现，此时我们可以做的:
    - 远程客户，帮助排查；
    - 由于用户也是偶现，远程也无法稳定复现，可以在关键代码新加日志，辅助排查；

- [x] **工程化的理解**

    项目工程化，涉及项目的整个生命周期，即从项目的技术选型、开发、联调、测试、上线、线上监控，目标是为了更好的用户体验、开发体验、线上质量。

    开发体验： 项目脚手架、前后端分离开发、快速 build、自动化测试、自动化部署；

    线上质量: 线上异常监控、性能监控；

    用户体验: 更快的响应(首屏性能优化、spa)、更流程的动画、更优化的交互(懒加载)；

- [x] **前端要不要理解业务**

    需要。

    原因:
    - 熟悉业务，可以增加在开发团队中的话语权、地位；
    - 可以提出更合理的技术方案；
    - 可以更快的定位问题；

- [x] **内部 npm 包更新通知使用包的项目**

    有几种方式:
    - npm 包开发完毕以后，向使用 npm 包的项目的相关负责人推送更新通知，及时更新；
    - 设置启动命令，在项目启动之前，检查某些包是否发生更新，如果有更新，强制更新；

- [x] **OKR 制定**

    - 自上而下拆分；
    - 业务支撑、效能提升(基础建设)、团队建设、个人成长；
    - OKR 评审；
    - OKR 回顾；
    - OKR 结果审查

- [x] **为什么开发组件的时候要 commonjs 和 esmodule 两种**

    npm 包默认采用 commonjs， package.json 的 main 属性指向 commonjs 包的 index 文件。

    采用 esmodule 之后， package.json 的 module 属性指向 esmodule 包的 index 文件。

    esmodule 支持 tree shaking。

    webpack 使用 import 引入 commonjs 包，但未使用，为什么不能 tree shaking 未使用的 module？

    tree shaking 要移除一个 module， 要判断模块是否依赖某个模块并且使用了该模块的对外 export。es6 的 import、export 可以支持 webpack 做静态分析， 而 commonjs 不支持静态分析。

- [x] 介绍一下做的比较好的项目

    最近做的比较好的项目，就是目前手上负责的 aicc 智能呼叫中心。

    aicc 呼叫中心项目采用了微前端的架构，将多个子应用聚合到一起。

    在这个项目中，除了日常的业务迭代以外，主要做了一下几个方面的事情:
    - 微前端架构的升级， ssr 动态路由 -> qiankun;
    - 性能优化，首屏性能优化 - 子应用走 ssr 和子应用交互优化 
    - 使用 module federation 进行逻辑复用；
    - 线上质量监控 - 主应用接入 sentry，将异常上报给指定负责人；
    - 脚手架工具 - sentry 一键接入；
    - 利用 qiankun，做业务重构升级；

- [x] 觉得目前还可以改进的地方

    目前在项目中可以改进的地方：

    - **历史遗留问题的持续处理：技术栈升级 + 业务重构 + 子应用风格统一**。
        
        业务重构 + 子应用风格统一的话，可以基于微前端，重新开一个新的子应用，升级依赖的技术栈，统一 UI 风格。

        对子应用可以做 webpack5 升级，可以使用 module federation 功能。在目前接触的业务中，会发下有较多的页面级的逻辑复用，直接使用 iframe 嵌入，有时候会存在免登的问题，而且通信也很复杂。可以考虑使用 mf 功能，方便复用代码。

    - **基础建设，提升开发效率**

        完善业务组件库、搭建低代码平台、完善内部脚手架(提供一键升级 webpack5、一键接入 sentry、一键接入 vite 等)；

    - **性能优化**

        接入 vite，提升开发效率；

        项目构建优化 - webpack 升级优化、项目首屏优化；

    - **流程优化**

        完善的线上异常监控处理

        完整的单元测试、UI 测试等

    - **团队建设**

        对外输出、团队成员能力成长


- [x] 日常工作

    - 业务线编码工作；
    - 做一些内部基础建设 - 异常监控、内部脚手架功能丰富、业务组件沉淀；
    - 项目升级 - webpack5 升级，最近准备做的有接入 vite；利用微前端重构核心业务；
    - 团队建设主要是对外影响力建设，目前主要是通过博客输出一些我们所使用的技术栈的总结，未来会持续输出解决方案、最佳实践；


- [x] aicc 业务相关

    aicc 主要的客户：涵盖金融、电商、保险，主要是百融、货拉拉、长清时代、欧派、杰士邦 等。

    未来的业务方向：聚焦电商领域

    aicc 未来的业务方向：
    - 聚焦种子客户，持续跟进，加强沟通，满足他们的需求；
    - CSM 工作台开发，提升客户运营的工作效率。(原来的工作模式，客户运营代运营的模式，一个运营负责几个客户，登录对方的账号，然后监控客户的数据。现在通过 CMS,可以提高人效);




    



    

    












