#### 准备内容

本次准备内容:

- 项目介绍

  - [x] SaaS 项目准备
  
    1. 微前端架构下项目部署的情况
    - SaaS (非容器话部署)
      1. 每个子应用通过 webpack 打包，生成 asset-manifest.json 文件，静态资源全部上传到 cdn;
      2. 获取当前 branch、commit 信息，以及入口 js 文件、css 文件的链接，通过 deploy 接口上传到 lego；
      3. 主应用通过 resource 接口，获取各个子应用当前 active 的 js、css 链接；
      4. 给 qiankun 的每一个子应用配资 entry 的 js、css 资源；
      5. 可以通过 lego 对子应用进行回滚，选定历史某个版本作为 active；

      主应用是一个 node 应用，部署的时候也是容器话部署，需要指定端口号、app_name、环境、项目类型 - node、启动命令。

    - byfe-scrm(容器化部署)
      1.  每个子应用通过 webpack 打包，静态资源上传到 cdn( 也可以不上传)；
      2.  将 build 文件做一个压缩包 htm.tar.gz;
      3.  使用 docker 打包一个镜像(指定 app_name、端口号、环境、项目类型 - html)；
      4.  部署镜像；
      5.  主应用配置路由对应的 nginx，将路由指向子应用的 entry；
      6.  回滚子应用可以通过镜像回滚；

      主应用是一个 html 静态应用，和子应用没有区别。

    2. 为什么之前 SaaS 之前用的是 ssr 架构？ 
   
       - 实现一个简单的 BFF 层，可以实现权限控制、客户定制、免登、微前端架构下子应用的聚合；
     
       - 首屏性能优化，主应用可以直出 html 页面；借助 SSR，子应用也可以直出首页，还可以预加载；

      免登的逻辑:
      1. 先通过一个接口，传入 id 信息生成一个 authToken；
      2. 将这个 authToken 信息，添加到 SaaS 应用的 url 里面；
      3. SaaS 应用的 server 端中间件，根据 url 中的 authToken 信息，返回一个 loading 页面；
      4. 在 loading 页面中，通过一个接口，传入 authToken，获取用去的 token 信息，写到当前域名下；
      5. 重新跳转到一开始需要跳转的页面；

      现在回过头来看，其实权限控制、客户定制、子应用聚合、免登逻辑都可以在主应用采用 spa 架构下也能实现。

    3. 微前端采用 qiankun 的初衷是什么？

        原来的架构的缺点:

        - 不能满足新的业务需求。原来的业务，是一级菜单在顶部，按照项目来划分，二级菜单是子应用里面的路由配置，采用原来的架构，用户使用应用时，割裂感不是很强。新业务线调整以后，功能划分不再以项目划分，而是根据业务线来划分的，这就导致了页面上的某一个一级菜单下的二级菜单来自不同的子应用。这个时候，原来的架构带来的体验就不好了，割裂感特别严重，这时就需要我们的 SaaS 应用也能达到 SPA 的效果。
  
        - 重构子项目、升级子项目技术栈的时候，只能通过 iframe 的方式接入, 开发体验和用户体验都不是很好；


    4. 为什么要使用 module federation?

        项目 A 要复用项目 B 中一个复杂业务逻辑，但两个项目使用的 antd 版本不一致。当时为了快速响应，特意为项目 B 中要复用的逻辑新建一个路由，然后项目 A 通过 iframe 的方式复用项目 B 的应用。

        这种方式缺点: 
        - 项目 A 中打开复用逻辑，加载非常慢，用户体验非常差；
        - 每次打开都需要重新加载；项
        - 目 A 和复用逻辑通信也非常麻烦，要通过 postmessage 的方式通信。

        改造方式: 将项目 A 和项目 B 同时升级到 webpack5， 然后使用 module federation 复用逻辑。

        项目 B 做 module federation 配置，打包完成以后，将静态文件上传到 cdn 上，并通过 deploy 脚本将对应的静态文件的 cdn 地址存到 lego。

        项目 A 每次打包的时候，都需要从 lego 通过接口拿到项目 B 的静态文件的 cdn 链接，然后添加到 remote 配置项中。

        注意，使用 module federation 以后，css 文件也会通过动态添加 style 标签的方式异步获取。 


    5. SaaS 首屏性能是怎么优化的？

        首屏打开时，对应的子页面也采用 ssr 的结构。
  
    6. 如何解决 qiankun 开启严格样式隔离后子应用重新激活出现页面抖动问题。
        

        出现这个问题的真实原因: qiankun 切换子应用时，会将原来的子应用卸载，再切换回来的时候会重新挂载。

        重新挂载的时候，会出现页面抖动的问题。

        原因是卸载子应用时，会把 css 链接保存下来，重新激活的时候再添加。添加 css 是一个异步的过程，导致先完成 dom tree 结构渲染，然后再添加样式，导致重绘，也就是页面抖动。

        通过 mutationObserver 来监听容器节点的新增节点操作，收集 link 节点的 href，把子应用的 dom 结构先从 dom tree 上移除 。通过 fetch + Promise.all 的方式先去获取样式资源，获取完毕以后再把 dom 结构添加到 dom tree 上。

        这种方案对比样式前缀方案，有优点也有缺点.

        优点: 不用给每个子应用添加样式前缀(不同子应用的构建工具、antd 版本不一样。可能不支持样式前缀改写)。

        缺点: 比样式前缀方式性能会差点

    7. qiankun 样式隔离的实践方案

        实践方案:
        - antd 添加样式前缀，体验会好，但是需要对子应用做改造，支持打包构建是添加样式前缀(antd 版本、构建工具类型会有影响)。
        - 开启严格样式隔离，不需要对子应用做改造，但是体验会比添加样式前缀会差点。


  - [x] Sentry 前端监控的亮点
  
    建立一套异常处理的闭环逻辑: 项目初始化、异常捕获、异常自动上报对应子应用、异常自动通知(飞书捷径)、异常处理；

    项目初始化: 通过 byai-cli 的 sentry-init 功能，可以根据项目的类型对项目进行 sentry 配置初始化。为每一个项目初始化 .sentryclirc 文件、初始化 package.json 中上传 source-map 的命令、初始化一个 HOC - SentryErrorWrapper、安装 @sentry/browser @sentry/tracing @sentry/react 等依赖包。

    微前端的异常处理逻辑: 
    - 主应用接入 Sentry.init 逻辑，通过 props 将 Sentry 对象传递给子应用；
    - 主应用对捕获的异常做拦截，分析异常属于哪个子应用，根据子应用的 dsn 重组 url，将异常上报给正确的项目；

    异常自动通知:
    - 配置一个飞书捷径，对接 Sentry 的 webhook，然后将异常推送到飞书群中，并指定负责人；
    - 相关负责人收到推送以后，建立 jira，分配给具体的处理人。

    Sentry 异常监控、性能监控的原理 !!

  
  - [x] Vite 接入的亮点

    对已有项目进行改造，开发模式采用支持 Vite、Webpack, 生产环境还是使用 Webpack。

    在改造过程中，总结遇到的问题，修复并抽象为插件： UrlResolvePlugin、LazyLoadPrefetchPlugin。

    提炼了了一套标准配置项、常用的 plugin，通过 byai-cli 的 vite-init 命令可一键初始化。

- 前端知识
  - [ ] 微前端
  - [ ] react
  - [ ] 构建工具 Webpack、Vite、Rollup、Esbuild
  - [ ] ssr
  - [ ] typescript
  - [ ] 前端监控
  - [ ] 基础知识

  - [ ] lerna、webrtc、前端工程化、k8s、docker、CI/CD 等
  
- 算法
  - [ ] 动态规划
  - [ ] 回溯
  - [ ] dfs / dfs
  - [ ] n 数之和
  - [ ] 左右指针 + 滑动窗口
  - [ ] 链表
  - [ ] 二叉树
  - [ ] 排序
  - [ ] 查找