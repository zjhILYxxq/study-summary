1. 常见的算法思路
    
    - 如果题目中，明确说明要获取全部值，可以考虑回溯(`dfs`) 算法。如果可以分解为子问题，可以考虑使用动态规划(`dp`) 算法。

        比较常见的使用回溯算法的题目: 获取全部子集、全排列、获取满足条件的全部集合。

        这类型的题目有几个关键点要考虑:
        - 给定集合中有重复元素，这个时候要排序，然后对重复元素做去重处理。在做去重处理时，需要借助一个 `cache`。
        - 给定元素，允许重复选择。这是时候，要递归的时候，元素要做去重处理。

    - 如果题目中，整个问题可以分解为子问题来求解，优先考虑动态规划算法(`dp`)。

        比较常见的使用 `dp` 算法的题目：爬楼梯、房屋偷盗问题、股票问题、剪绳子问题等。

    - 如果题目，需要遍历二维数组、图、二叉树的，可以考虑 `dfs`、`bfs` 算法。

        比较常见的题目: 岛屿淹没问题、全部子集问题、全排列问题等

    - 链表问题，常用解法: 正常遍历、双指针、快慢指针、递归，解的时候常常需要配合其他数据结构使用。

        比较常见的题目: 
        - 寻找倒数第 `k` 个节点，解法 - 快慢指针，快指针先走 `k` 步, 然后快慢指针一起走；
        - 寻找链表的中间节点，解法 - 快慢指针，快指针每次走两步，慢指针每次走一步；
        - 判断链表是否有环，解法 - 快慢指针，快指针如果能追上慢指针，就表明有环；
        - 判断链表环的起点，解法 - 快指针追上慢指针以后，慢指针指向 `head`，快指针继续前进，两者再次相遇的节点就是环的起点
        - 找到两个链表相交的节点；
        - 合并有序链表；
        - 链表反转, 解法 - 递归；
        - ...

    - 二叉树问题，常用解法： `dfs`、`bfs`;
  
        二叉树的问题，常用解法: 递归。
  
    - 排序问题

        插入排序、冒泡排序、快速排序、堆排序

        冒泡排序： `n` 个元素，要进行 `n - 1` 轮排序，每一轮确定一个元素的位置。

        快速排序： 确定一个标兵位置，将小于标兵的元素移动左边，大于标兵的元素移到右边，然后再递归的处理标兵两遍的元素集。

        堆排序:
        - 如何将一个 list 转化为堆 - 从第一个不是叶子节点的节点开始，做下沉操作；
        - 入堆 - 将元素添加到堆底，判断元素是否需要上升；
        - 出堆 - 将堆顶元素出栈，然后将堆最下边的元素放到堆顶，然后对堆顶元素做下沉操作；

    - `n` 数之和问题

        `2` 数之和、`3` 数之和、`4` 数之和。

        `n` 数之和的解法，就是将问题转化为 `n - 1` 数之和，最后转化为 `2` 数之和问题。

        `2` 数之和问题，解法: 左右指针。

        有一个关键点要注意, 就是重复元素的处理。要先排序，然后做去重处理。

        去重的关键就是跳过已经处理过的元素

    - 求取子串问题 - 解法滑动窗口
  
        滑动窗口有两个关键步骤 - 扩大窗口和缩小窗口
    
    - 其他算法问题

        手写 `promise`、`deep clone`、`event emitter`、 `url` 的编码解码、多维数组扁平化、扁平化数据结构和树的相互转化。

        手写 `promise`: 关键是要实现 `async task queue`、`resolve`、`reject`、`then`、`all`、`race`、`allSettled`、`any` 等。

        `url` 的编码解码:
        - 使用 `encodeURI` 编码以后的 `uri` 可以继续访问，而使用 `encodeComponentURI` 编码以后的 `uri` 不可以访问；
        - `encodeURI` / `decodeURI`, `encodeComponentURI` / `decodeComponentURI`

        




